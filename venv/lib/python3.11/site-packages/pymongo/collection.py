# Copyright 2009-present MongoDB, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Collection level utilities for Mongo."""
<<<<<<< HEAD

import datetime
import warnings

from bson.code import Code
from bson.objectid import ObjectId
from bson.py3compat import (_unicode,
                            abc,
                            integer_types,
                            string_type)
from bson.raw_bson import RawBSONDocument
from bson.codec_options import CodecOptions
from bson.son import SON
from pymongo import (common,
                     helpers,
                     message)
from pymongo.aggregation import (_CollectionAggregationCommand,
                                 _CollectionRawAggregationCommand)
from pymongo.bulk import BulkOperationBuilder, _Bulk
from pymongo.command_cursor import CommandCursor, RawBatchCommandCursor
from pymongo.common import ORDERED_TYPES
from pymongo.collation import validate_collation_or_none
from pymongo.change_stream import CollectionChangeStream
from pymongo.cursor import Cursor, RawBatchCursor
from pymongo.errors import (BulkWriteError,
                            ConfigurationError,
                            InvalidName,
                            InvalidOperation,
                            OperationFailure)
from pymongo.helpers import (_check_write_command_response,
                             _raise_last_error)
from pymongo.message import _UNICODE_REPLACE_CODEC_OPTIONS
from pymongo.operations import IndexModel
from pymongo.read_preferences import ReadPreference
from pymongo.results import (BulkWriteResult,
                             DeleteResult,
                             InsertOneResult,
                             InsertManyResult,
                             UpdateResult)
from pymongo.write_concern import WriteConcern

_UJOIN = u"%s.%s"
_FIND_AND_MODIFY_DOC_FIELDS = {'value': 1}
_HAYSTACK_MSG = (
    "geoHaystack indexes are deprecated as of MongoDB 4.4."
    " Instead, create a 2d index and use $geoNear or $geoWithin."
    " See https://dochub.mongodb.org/core/4.4-deprecate-geoHaystack")


class ReturnDocument(object):
=======
from __future__ import annotations

from collections import abc
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    ContextManager,
    Generic,
    Iterable,
    Iterator,
    Mapping,
    MutableMapping,
    NoReturn,
    Optional,
    Sequence,
    Type,
    TypeVar,
    Union,
    cast,
)

from bson.codec_options import DEFAULT_CODEC_OPTIONS, CodecOptions
from bson.objectid import ObjectId
from bson.raw_bson import RawBSONDocument
from bson.son import SON
from bson.timestamp import Timestamp
from pymongo import ASCENDING, _csot, common, helpers, message
from pymongo.aggregation import (
    _CollectionAggregationCommand,
    _CollectionRawAggregationCommand,
)
from pymongo.bulk import _Bulk
from pymongo.change_stream import CollectionChangeStream
from pymongo.collation import validate_collation_or_none
from pymongo.command_cursor import CommandCursor, RawBatchCommandCursor
from pymongo.common import _ecoc_coll_name, _esc_coll_name
from pymongo.cursor import Cursor, RawBatchCursor
from pymongo.errors import (
    ConfigurationError,
    InvalidName,
    InvalidOperation,
    OperationFailure,
)
from pymongo.helpers import _check_write_command_response
from pymongo.message import _UNICODE_REPLACE_CODEC_OPTIONS
from pymongo.operations import (
    DeleteMany,
    DeleteOne,
    IndexModel,
    InsertOne,
    ReplaceOne,
    SearchIndexModel,
    UpdateMany,
    UpdateOne,
    _IndexKeyHint,
    _IndexList,
    _Op,
)
from pymongo.read_concern import DEFAULT_READ_CONCERN, ReadConcern
from pymongo.read_preferences import ReadPreference, _ServerMode
from pymongo.results import (
    BulkWriteResult,
    DeleteResult,
    InsertManyResult,
    InsertOneResult,
    UpdateResult,
)
from pymongo.typings import _CollationIn, _DocumentType, _DocumentTypeArg, _Pipeline
from pymongo.write_concern import DEFAULT_WRITE_CONCERN, WriteConcern, validate_boolean

T = TypeVar("T")

_FIND_AND_MODIFY_DOC_FIELDS = {"value": 1}


_WriteOp = Union[
    InsertOne[_DocumentType],
    DeleteOne,
    DeleteMany,
    ReplaceOne[_DocumentType],
    UpdateOne,
    UpdateMany,
]


class ReturnDocument:
>>>>>>> origin/master
    """An enum used with
    :meth:`~pymongo.collection.Collection.find_one_and_replace` and
    :meth:`~pymongo.collection.Collection.find_one_and_update`.
    """
<<<<<<< HEAD
=======

>>>>>>> origin/master
    BEFORE = False
    """Return the original document before it was updated/replaced, or
    ``None`` if no document matches the query.
    """
    AFTER = True
    """Return the updated/replaced or inserted document."""


<<<<<<< HEAD
class Collection(common.BaseObject):
    """A Mongo collection.
    """

    def __init__(self, database, name, create=False, codec_options=None,
                 read_preference=None, write_concern=None, read_concern=None,
                 session=None, **kwargs):
        """Get / create a Mongo collection.

        Raises :class:`TypeError` if `name` is not an instance of
        :class:`basestring` (:class:`str` in python 3). Raises
        :class:`~pymongo.errors.InvalidName` if `name` is not a valid
        collection name. Any additional keyword arguments will be used
=======
if TYPE_CHECKING:
    from pymongo.aggregation import _AggregationCommand
    from pymongo.client_session import ClientSession
    from pymongo.collation import Collation
    from pymongo.database import Database
    from pymongo.pool import Connection
    from pymongo.server import Server


class Collection(common.BaseObject, Generic[_DocumentType]):
    """A Mongo collection."""

    def __init__(
        self,
        database: Database[_DocumentType],
        name: str,
        create: Optional[bool] = False,
        codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
        read_preference: Optional[_ServerMode] = None,
        write_concern: Optional[WriteConcern] = None,
        read_concern: Optional[ReadConcern] = None,
        session: Optional[ClientSession] = None,
        **kwargs: Any,
    ) -> None:
        """Get / create a Mongo collection.

        Raises :class:`TypeError` if `name` is not an instance of
        :class:`str`. Raises :class:`~pymongo.errors.InvalidName` if `name` is
        not a valid collection name. Any additional keyword arguments will be used
>>>>>>> origin/master
        as options passed to the create command. See
        :meth:`~pymongo.database.Database.create_collection` for valid
        options.

        If `create` is ``True``, `collation` is specified, or any additional
        keyword arguments are present, a ``create`` command will be
        sent, using ``session`` if specified. Otherwise, a ``create`` command
        will not be sent and the collection will be created implicitly on first
        use. The optional ``session`` argument is *only* used for the ``create``
        command, it is not associated with the collection afterward.

<<<<<<< HEAD
        :Parameters:
          - `database`: the database to get a collection from
          - `name`: the name of the collection to get
          - `create` (optional): if ``True``, force collection
            creation even without options being set
          - `codec_options` (optional): An instance of
            :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
            default) database.codec_options is used.
          - `read_preference` (optional): The read preference to use. If
            ``None`` (the default) database.read_preference is used.
          - `write_concern` (optional): An instance of
            :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
            default) database.write_concern is used.
          - `read_concern` (optional): An instance of
            :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
            default) database.read_concern is used.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. If a collation is provided,
            it will be passed to the create collection command. This option is
            only supported on MongoDB 3.4 and above.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession` that is used with
            the create collection command
          - `**kwargs` (optional): additional keyword arguments will
            be passed as options for the create collection command

=======
        :param database: the database to get a collection from
        :param name: the name of the collection to get
        :param create: if ``True``, force collection
            creation even without options being set
        :param codec_options: An instance of
            :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
            default) database.codec_options is used.
        :param read_preference: The read preference to use. If
            ``None`` (the default) database.read_preference is used.
        :param write_concern: An instance of
            :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
            default) database.write_concern is used.
        :param read_concern: An instance of
            :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
            default) database.read_concern is used.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`. If a collation is provided,
            it will be passed to the create collection command.
        :param session: a
            :class:`~pymongo.client_session.ClientSession` that is used with
            the create collection command
        :param kwargs: additional keyword arguments will
            be passed as options for the create collection command

        .. versionchanged:: 4.2
           Added the ``clusteredIndex`` and ``encryptedFields`` parameters.

        .. versionchanged:: 4.0
           Removed the reindex, map_reduce, inline_map_reduce,
           parallel_scan, initialize_unordered_bulk_op,
           initialize_ordered_bulk_op, group, count, insert, save,
           update, remove, find_and_modify, and ensure_index methods. See the
           :ref:`pymongo4-migration-guide`.

>>>>>>> origin/master
        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.4
           Support the `collation` option.

        .. versionchanged:: 3.2
           Added the read_concern option.

        .. versionchanged:: 3.0
           Added the codec_options, read_preference, and write_concern options.
           Removed the uuid_subtype attribute.
           :class:`~pymongo.collection.Collection` no longer returns an
           instance of :class:`~pymongo.collection.Collection` for attribute
           names with leading underscores. You must use dict-style lookups
           instead::

               collection['__my_collection__']

           Not:

               collection.__my_collection__

<<<<<<< HEAD
        .. versionchanged:: 2.2
           Removed deprecated argument: options

        .. versionadded:: 2.1
           uuid_subtype attribute

        .. mongodoc:: collections
        """
        super(Collection, self).__init__(
            codec_options or database.codec_options,
            read_preference or database.read_preference,
            write_concern or database.write_concern,
            read_concern or database.read_concern)

        if not isinstance(name, string_type):
            raise TypeError("name must be an instance "
                            "of %s" % (string_type.__name__,))

        if not name or ".." in name:
            raise InvalidName("collection names cannot be empty")
        if "$" in name and not (name.startswith("oplog.$main") or
                                name.startswith("$cmd")):
            raise InvalidName("collection names must not "
                              "contain '$': %r" % name)
        if name[0] == "." or name[-1] == ".":
            raise InvalidName("collection names must not start "
                              "or end with '.': %r" % name)
        if "\x00" in name:
            raise InvalidName("collection names must not contain the "
                              "null character")
        collation = validate_collation_or_none(kwargs.pop('collation', None))

        self.__database = database
        self.__name = _unicode(name)
        self.__full_name = _UJOIN % (self.__database.name, self.__name)
        if create or kwargs or collation:
            self.__create(kwargs, collation, session)

        self.__write_response_codec_options = self.codec_options._replace(
            unicode_decode_error_handler='replace',
            document_class=dict)

    def _socket_for_reads(self, session):
        return self.__database.client._socket_for_reads(
            self._read_preference_for(session), session)

    def _socket_for_writes(self, session):
        return self.__database.client._socket_for_writes(session)

    def _command(self, sock_info, command, slave_ok=False,
                 read_preference=None,
                 codec_options=None, check=True, allowable_errors=None,
                 read_concern=None,
                 write_concern=None,
                 collation=None,
                 session=None,
                 retryable_write=False,
                 user_fields=None):
        """Internal command helper.

        :Parameters:
          - `sock_info` - A SocketInfo instance.
          - `command` - The command itself, as a SON instance.
          - `slave_ok`: whether to set the SlaveOkay wire protocol bit.
          - `codec_options` (optional) - An instance of
            :class:`~bson.codec_options.CodecOptions`.
          - `check`: raise OperationFailure if there are errors
          - `allowable_errors`: errors to ignore if `check` is True
          - `read_concern` (optional) - An instance of
            :class:`~pymongo.read_concern.ReadConcern`.
          - `write_concern`: An instance of
            :class:`~pymongo.write_concern.WriteConcern`. This option is only
            valid for MongoDB 3.4 and above.
          - `collation` (optional) - An instance of
            :class:`~pymongo.collation.Collation`.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `retryable_write` (optional): True if this command is a retryable
            write.
          - `user_fields` (optional): Response fields that should be decoded
            using the TypeDecoders from codec_options, passed to
            bson._decode_all_selective.

        :Returns:
          The result document.
        """
        with self.__database.client._tmp_session(session) as s:
            return sock_info.command(
                self.__database.name,
                command,
                slave_ok,
=======
        .. seealso:: The MongoDB documentation on `collections <https://dochub.mongodb.org/core/collections>`_.
        """
        super().__init__(
            codec_options or database.codec_options,
            read_preference or database.read_preference,
            write_concern or database.write_concern,
            read_concern or database.read_concern,
        )
        if not isinstance(name, str):
            raise TypeError("name must be an instance of str")

        if not name or ".." in name:
            raise InvalidName("collection names cannot be empty")
        if "$" in name and not (name.startswith(("oplog.$main", "$cmd"))):
            raise InvalidName("collection names must not contain '$': %r" % name)
        if name[0] == "." or name[-1] == ".":
            raise InvalidName("collection names must not start or end with '.': %r" % name)
        if "\x00" in name:
            raise InvalidName("collection names must not contain the null character")
        collation = validate_collation_or_none(kwargs.pop("collation", None))

        self.__database: Database[_DocumentType] = database
        self.__name = name
        self.__full_name = f"{self.__database.name}.{self.__name}"
        self.__write_response_codec_options = self.codec_options._replace(
            unicode_decode_error_handler="replace", document_class=dict
        )
        self._timeout = database.client.options.timeout
        encrypted_fields = kwargs.pop("encryptedFields", None)
        if create or kwargs or collation:
            if encrypted_fields:
                common.validate_is_mapping("encrypted_fields", encrypted_fields)
                opts = {"clusteredIndex": {"key": {"_id": 1}, "unique": True}}
                self.__create(
                    _esc_coll_name(encrypted_fields, name), opts, None, session, qev2_required=True
                )
                self.__create(_ecoc_coll_name(encrypted_fields, name), opts, None, session)
                self.__create(name, kwargs, collation, session, encrypted_fields=encrypted_fields)
                self.create_index([("__safeContent__", ASCENDING)], session)
            else:
                self.__create(name, kwargs, collation, session)

    def _conn_for_writes(
        self, session: Optional[ClientSession], operation: str
    ) -> ContextManager[Connection]:
        return self.__database.client._conn_for_writes(session, operation)

    def _command(
        self,
        conn: Connection,
        command: MutableMapping[str, Any],
        read_preference: Optional[_ServerMode] = None,
        codec_options: Optional[CodecOptions] = None,
        check: bool = True,
        allowable_errors: Optional[Sequence[Union[str, int]]] = None,
        read_concern: Optional[ReadConcern] = None,
        write_concern: Optional[WriteConcern] = None,
        collation: Optional[_CollationIn] = None,
        session: Optional[ClientSession] = None,
        retryable_write: bool = False,
        user_fields: Optional[Any] = None,
    ) -> Mapping[str, Any]:
        """Internal command helper.

        :param conn` - A Connection instance.
        :param command` - The command itself, as a :class:`~bson.son.SON` instance.
        :param read_preference` (optional) - The read preference to use.
        :param codec_options` (optional) - An instance of
            :class:`~bson.codec_options.CodecOptions`.
        :param check: raise OperationFailure if there are errors
        :param allowable_errors: errors to ignore if `check` is True
        :param read_concern` (optional) - An instance of
            :class:`~pymongo.read_concern.ReadConcern`.
        :param write_concern: An instance of
            :class:`~pymongo.write_concern.WriteConcern`.
        :param collation` (optional) - An instance of
            :class:`~pymongo.collation.Collation`.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param retryable_write: True if this command is a retryable
            write.
        :param user_fields: Response fields that should be decoded
            using the TypeDecoders from codec_options, passed to
            bson._decode_all_selective.

        :return: The result document.
        """
        with self.__database.client._tmp_session(session) as s:
            return conn.command(
                self.__database.name,
                command,
>>>>>>> origin/master
                read_preference or self._read_preference_for(session),
                codec_options or self.codec_options,
                check,
                allowable_errors,
                read_concern=read_concern,
                write_concern=write_concern,
                parse_write_concern_error=True,
                collation=collation,
                session=s,
                client=self.__database.client,
                retryable_write=retryable_write,
<<<<<<< HEAD
                user_fields=user_fields)

    def __create(self, options, collation, session):
        """Sends a create command with the given options.
        """
        cmd = SON([("create", self.__name)])
=======
                user_fields=user_fields,
            )

    def __create(
        self,
        name: str,
        options: MutableMapping[str, Any],
        collation: Optional[_CollationIn],
        session: Optional[ClientSession],
        encrypted_fields: Optional[Mapping[str, Any]] = None,
        qev2_required: bool = False,
    ) -> None:
        """Sends a create command with the given options."""
        cmd: dict[str, Any] = {"create": name}
        if encrypted_fields:
            cmd["encryptedFields"] = encrypted_fields

>>>>>>> origin/master
        if options:
            if "size" in options:
                options["size"] = float(options["size"])
            cmd.update(options)
<<<<<<< HEAD
        with self._socket_for_writes(session) as sock_info:
            self._command(
                sock_info, cmd, read_preference=ReadPreference.PRIMARY,
                write_concern=self._write_concern_for(session),
                collation=collation, session=session)

    def __getattr__(self, name):
=======
        with self._conn_for_writes(session, operation=_Op.CREATE) as conn:
            if qev2_required and conn.max_wire_version < 21:
                raise ConfigurationError(
                    "Driver support of Queryable Encryption is incompatible with server. "
                    "Upgrade server to use Queryable Encryption. "
                    f"Got maxWireVersion {conn.max_wire_version} but need maxWireVersion >= 21 (MongoDB >=7.0)"
                )

            self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                write_concern=self._write_concern_for(session),
                collation=collation,
                session=session,
            )

    def __getattr__(self, name: str) -> Collection[_DocumentType]:
>>>>>>> origin/master
        """Get a sub-collection of this collection by name.

        Raises InvalidName if an invalid collection name is used.

<<<<<<< HEAD
        :Parameters:
          - `name`: the name of the collection to get
        """
        if name.startswith('_'):
            full_name = _UJOIN % (self.__name, name)
            raise AttributeError(
                "Collection has no attribute %r. To access the %s"
                " collection, use database['%s']." % (
                    name, full_name, full_name))
        return self.__getitem__(name)

    def __getitem__(self, name):
        return Collection(self.__database,
                          _UJOIN % (self.__name, name),
                          False,
                          self.codec_options,
                          self.read_preference,
                          self.write_concern,
                          self.read_concern)

    def __repr__(self):
        return "Collection(%r, %r)" % (self.__database, self.__name)

    def __eq__(self, other):
        if isinstance(other, Collection):
            return (self.__database == other.database and
                    self.__name == other.name)
        return NotImplemented

    def __ne__(self, other):
        return not self == other

    @property
    def full_name(self):
=======
        :param name: the name of the collection to get
        """
        if name.startswith("_"):
            full_name = f"{self.__name}.{name}"
            raise AttributeError(
                f"Collection has no attribute {name!r}. To access the {full_name}"
                f" collection, use database['{full_name}']."
            )
        return self.__getitem__(name)

    def __getitem__(self, name: str) -> Collection[_DocumentType]:
        return Collection(
            self.__database,
            f"{self.__name}.{name}",
            False,
            self.codec_options,
            self.read_preference,
            self.write_concern,
            self.read_concern,
        )

    def __repr__(self) -> str:
        return f"Collection({self.__database!r}, {self.__name!r})"

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Collection):
            return self.__database == other.database and self.__name == other.name
        return NotImplemented

    def __ne__(self, other: Any) -> bool:
        return not self == other

    def __hash__(self) -> int:
        return hash((self.__database, self.__name))

    def __bool__(self) -> NoReturn:
        raise NotImplementedError(
            "Collection objects do not implement truth "
            "value testing or bool(). Please compare "
            "with None instead: collection is not None"
        )

    @property
    def full_name(self) -> str:
>>>>>>> origin/master
        """The full name of this :class:`Collection`.

        The full name is of the form `database_name.collection_name`.
        """
        return self.__full_name

    @property
<<<<<<< HEAD
    def name(self):
=======
    def name(self) -> str:
>>>>>>> origin/master
        """The name of this :class:`Collection`."""
        return self.__name

    @property
<<<<<<< HEAD
    def database(self):
=======
    def database(self) -> Database[_DocumentType]:
>>>>>>> origin/master
        """The :class:`~pymongo.database.Database` that this
        :class:`Collection` is a part of.
        """
        return self.__database

<<<<<<< HEAD
    def with_options(self, codec_options=None, read_preference=None,
                     write_concern=None, read_concern=None):
=======
    def with_options(
        self,
        codec_options: Optional[CodecOptions[_DocumentTypeArg]] = None,
        read_preference: Optional[_ServerMode] = None,
        write_concern: Optional[WriteConcern] = None,
        read_concern: Optional[ReadConcern] = None,
    ) -> Collection[_DocumentType]:
>>>>>>> origin/master
        """Get a clone of this collection changing the specified settings.

          >>> coll1.read_preference
          Primary()
          >>> from pymongo import ReadPreference
          >>> coll2 = coll1.with_options(read_preference=ReadPreference.SECONDARY)
          >>> coll1.read_preference
          Primary()
          >>> coll2.read_preference
          Secondary(tag_sets=None)

<<<<<<< HEAD
        :Parameters:
          - `codec_options` (optional): An instance of
            :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
            default) the :attr:`codec_options` of this :class:`Collection`
            is used.
          - `read_preference` (optional): The read preference to use. If
            ``None`` (the default) the :attr:`read_preference` of this
            :class:`Collection` is used. See :mod:`~pymongo.read_preferences`
            for options.
          - `write_concern` (optional): An instance of
            :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
            default) the :attr:`write_concern` of this :class:`Collection`
            is used.
          - `read_concern` (optional): An instance of
=======
        :param codec_options: An instance of
            :class:`~bson.codec_options.CodecOptions`. If ``None`` (the
            default) the :attr:`codec_options` of this :class:`Collection`
            is used.
        :param read_preference: The read preference to use. If
            ``None`` (the default) the :attr:`read_preference` of this
            :class:`Collection` is used. See :mod:`~pymongo.read_preferences`
            for options.
        :param write_concern: An instance of
            :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the
            default) the :attr:`write_concern` of this :class:`Collection`
            is used.
        :param read_concern: An instance of
>>>>>>> origin/master
            :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the
            default) the :attr:`read_concern` of this :class:`Collection`
            is used.
        """
<<<<<<< HEAD
        return Collection(self.__database,
                          self.__name,
                          False,
                          codec_options or self.codec_options,
                          read_preference or self.read_preference,
                          write_concern or self.write_concern,
                          read_concern or self.read_concern)

    def initialize_unordered_bulk_op(self, bypass_document_validation=False):
        """**DEPRECATED** - Initialize an unordered batch of write operations.

        Operations will be performed on the server in arbitrary order,
        possibly in parallel. All operations will be attempted.

        :Parameters:
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.

        Returns a :class:`~pymongo.bulk.BulkOperationBuilder` instance.

        See :ref:`unordered_bulk` for examples.

        .. note:: `bypass_document_validation` requires server version
          **>= 3.2**

        .. versionchanged:: 3.5
           Deprecated. Use :meth:`~pymongo.collection.Collection.bulk_write`
           instead.

        .. versionchanged:: 3.2
           Added bypass_document_validation support

        .. versionadded:: 2.7
        """
        warnings.warn("initialize_unordered_bulk_op is deprecated",
                      DeprecationWarning, stacklevel=2)
        return BulkOperationBuilder(self, False, bypass_document_validation)

    def initialize_ordered_bulk_op(self, bypass_document_validation=False):
        """**DEPRECATED** - Initialize an ordered batch of write operations.

        Operations will be performed on the server serially, in the
        order provided. If an error occurs all remaining operations
        are aborted.

        :Parameters:
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.

        Returns a :class:`~pymongo.bulk.BulkOperationBuilder` instance.

        See :ref:`ordered_bulk` for examples.

        .. note:: `bypass_document_validation` requires server version
          **>= 3.2**

        .. versionchanged:: 3.5
           Deprecated. Use :meth:`~pymongo.collection.Collection.bulk_write`
           instead.

        .. versionchanged:: 3.2
           Added bypass_document_validation support

        .. versionadded:: 2.7
        """
        warnings.warn("initialize_ordered_bulk_op is deprecated",
                      DeprecationWarning, stacklevel=2)
        return BulkOperationBuilder(self, True, bypass_document_validation)

    def bulk_write(self, requests, ordered=True,
                   bypass_document_validation=False, session=None):
=======
        return Collection(
            self.__database,
            self.__name,
            False,
            codec_options or self.codec_options,
            read_preference or self.read_preference,
            write_concern or self.write_concern,
            read_concern or self.read_concern,
        )

    @_csot.apply
    def bulk_write(
        self,
        requests: Sequence[_WriteOp[_DocumentType]],
        ordered: bool = True,
        bypass_document_validation: bool = False,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        let: Optional[Mapping] = None,
    ) -> BulkWriteResult:
>>>>>>> origin/master
        """Send a batch of write operations to the server.

        Requests are passed as a list of write operation instances (
        :class:`~pymongo.operations.InsertOne`,
        :class:`~pymongo.operations.UpdateOne`,
        :class:`~pymongo.operations.UpdateMany`,
        :class:`~pymongo.operations.ReplaceOne`,
        :class:`~pymongo.operations.DeleteOne`, or
        :class:`~pymongo.operations.DeleteMany`).

          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': ObjectId('54f62e60fba5226811f634ef')}
          {u'x': 1, u'_id': ObjectId('54f62e60fba5226811f634f0')}
=======
          {'x': 1, '_id': ObjectId('54f62e60fba5226811f634ef')}
          {'x': 1, '_id': ObjectId('54f62e60fba5226811f634f0')}
>>>>>>> origin/master
          >>> # DeleteMany, UpdateOne, and UpdateMany are also available.
          ...
          >>> from pymongo import InsertOne, DeleteOne, ReplaceOne
          >>> requests = [InsertOne({'y': 1}), DeleteOne({'x': 1}),
          ...             ReplaceOne({'w': 1}, {'z': 1}, upsert=True)]
          >>> result = db.test.bulk_write(requests)
          >>> result.inserted_count
          1
          >>> result.deleted_count
          1
          >>> result.modified_count
          0
          >>> result.upserted_ids
          {2: ObjectId('54f62ee28891e756a6e1abd5')}
          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': ObjectId('54f62e60fba5226811f634f0')}
          {u'y': 1, u'_id': ObjectId('54f62ee2fba5226811f634f1')}
          {u'z': 1, u'_id': ObjectId('54f62ee28891e756a6e1abd5')}

        :Parameters:
          - `requests`: A list of write operations (see examples above).
          - `ordered` (optional): If ``True`` (the default) requests will be
=======
          {'x': 1, '_id': ObjectId('54f62e60fba5226811f634f0')}
          {'y': 1, '_id': ObjectId('54f62ee2fba5226811f634f1')}
          {'z': 1, '_id': ObjectId('54f62ee28891e756a6e1abd5')}

        :param requests: A list of write operations (see examples above).
        :param ordered: If ``True`` (the default) requests will be
>>>>>>> origin/master
            performed on the server serially, in the order provided. If an error
            occurs all remaining operations are aborted. If ``False`` requests
            will be performed on the server in arbitrary order, possibly in
            parallel, and all operations will be attempted.
<<<<<<< HEAD
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          An instance of :class:`~pymongo.results.BulkWriteResult`.
=======
        :param bypass_document_validation: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").

        :return: An instance of :class:`~pymongo.results.BulkWriteResult`.
>>>>>>> origin/master

        .. seealso:: :ref:`writes-and-ids`

        .. note:: `bypass_document_validation` requires server version
          **>= 3.2**

<<<<<<< HEAD
=======
        .. versionchanged:: 4.1
           Added ``comment`` parameter.
           Added ``let`` parameter.

>>>>>>> origin/master
        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.2
          Added bypass_document_validation support

        .. versionadded:: 3.0
        """
        common.validate_list("requests", requests)

<<<<<<< HEAD
        blk = _Bulk(self, ordered, bypass_document_validation)
=======
        blk = _Bulk(self, ordered, bypass_document_validation, comment=comment, let=let)
>>>>>>> origin/master
        for request in requests:
            try:
                request._add_to_bulk(blk)
            except AttributeError:
<<<<<<< HEAD
                raise TypeError("%r is not a valid request" % (request,))

        write_concern = self._write_concern_for(session)
        bulk_api_result = blk.execute(write_concern, session)
=======
                raise TypeError(f"{request!r} is not a valid request") from None

        write_concern = self._write_concern_for(session)
        bulk_api_result = blk.execute(write_concern, session, _Op.INSERT)
>>>>>>> origin/master
        if bulk_api_result is not None:
            return BulkWriteResult(bulk_api_result, True)
        return BulkWriteResult({}, False)

<<<<<<< HEAD
    def _legacy_write(self, sock_info, name, cmd, op_id,
                      bypass_doc_val, func, *args):
        """Internal legacy unacknowledged write helper."""
        # Cannot have both unacknowledged write and bypass document validation.
        if bypass_doc_val and sock_info.max_wire_version >= 4:
            raise OperationFailure("Cannot set bypass_document_validation with"
                                   " unacknowledged write concern")
        listeners = self.database.client._event_listeners
        publish = listeners.enabled_for_commands

        if publish:
            start = datetime.datetime.now()
        args = args + (sock_info.compression_context,)
        rqst_id, msg, max_size = func(*args)
        if publish:
            duration = datetime.datetime.now() - start
            listeners.publish_command_start(
                cmd, self.__database.name, rqst_id, sock_info.address, op_id)
            start = datetime.datetime.now()
        try:
            result = sock_info.legacy_write(rqst_id, msg, max_size, False)
        except Exception as exc:
            if publish:
                dur = (datetime.datetime.now() - start) + duration
                if isinstance(exc, OperationFailure):
                    details = exc.details
                    # Succeed if GLE was successful and this is a write error.
                    if details.get("ok") and "n" in details:
                        reply = message._convert_write_result(
                            name, cmd, details)
                        listeners.publish_command_success(
                            dur, reply, name, rqst_id, sock_info.address, op_id)
                        raise
                else:
                    details = message._convert_exception(exc)
                listeners.publish_command_failure(
                    dur, details, name, rqst_id, sock_info.address, op_id)
            raise
        if publish:
            if result is not None:
                reply = message._convert_write_result(name, cmd, result)
            else:
                # Comply with APM spec.
                reply = {'ok': 1}
            duration = (datetime.datetime.now() - start) + duration
            listeners.publish_command_success(
                duration, reply, name, rqst_id, sock_info.address, op_id)
        return result

    def _insert_one(
            self, doc, ordered,
            check_keys, manipulate, write_concern, op_id, bypass_doc_val,
            session):
        """Internal helper for inserting a single document."""
        if manipulate:
            doc = self.__database._apply_incoming_manipulators(doc, self)
            if not isinstance(doc, RawBSONDocument) and '_id' not in doc:
                doc['_id'] = ObjectId()
            doc = self.__database._apply_incoming_copying_manipulators(doc,
                                                                       self)
        write_concern = write_concern or self.write_concern
        acknowledged = write_concern.acknowledged
        command = SON([('insert', self.name),
                       ('ordered', ordered),
                       ('documents', [doc])])
        if not write_concern.is_server_default:
            command['writeConcern'] = write_concern.document

        def _insert_command(session, sock_info, retryable_write):
            if not sock_info.op_msg_enabled and not acknowledged:
                # Legacy OP_INSERT.
                return self._legacy_write(
                    sock_info, 'insert', command, op_id,
                    bypass_doc_val, message.insert, self.__full_name,
                    [doc], check_keys, False, write_concern.document, False,
                    self.__write_response_codec_options)

            if bypass_doc_val and sock_info.max_wire_version >= 4:
                command['bypassDocumentValidation'] = True

            result = sock_info.command(
=======
    def _insert_one(
        self,
        doc: Mapping[str, Any],
        ordered: bool,
        write_concern: WriteConcern,
        op_id: Optional[int],
        bypass_doc_val: bool,
        session: Optional[ClientSession],
        comment: Optional[Any] = None,
    ) -> Any:
        """Internal helper for inserting a single document."""
        write_concern = write_concern or self.write_concern
        acknowledged = write_concern.acknowledged
        command = {"insert": self.name, "ordered": ordered, "documents": [doc]}
        if comment is not None:
            command["comment"] = comment

        def _insert_command(
            session: Optional[ClientSession], conn: Connection, retryable_write: bool
        ) -> None:
            if bypass_doc_val:
                command["bypassDocumentValidation"] = True

            result = conn.command(
>>>>>>> origin/master
                self.__database.name,
                command,
                write_concern=write_concern,
                codec_options=self.__write_response_codec_options,
<<<<<<< HEAD
                check_keys=check_keys,
                session=session,
                client=self.__database.client,
                retryable_write=retryable_write)
=======
                session=session,
                client=self.__database.client,
                retryable_write=retryable_write,
            )
>>>>>>> origin/master

            _check_write_command_response(result)

        self.__database.client._retryable_write(
<<<<<<< HEAD
            acknowledged, _insert_command, session)

        if not isinstance(doc, RawBSONDocument):
            return doc.get('_id')

    def _insert(self, docs, ordered=True, check_keys=True,
                manipulate=False, write_concern=None, op_id=None,
                bypass_doc_val=False, session=None):
        """Internal insert helper."""
        if isinstance(docs, abc.Mapping):
            return self._insert_one(
                docs, ordered, check_keys, manipulate, write_concern, op_id,
                bypass_doc_val, session)

        ids = []

        if manipulate:
            def gen():
                """Generator that applies SON manipulators to each document
                and adds _id if necessary.
                """
                _db = self.__database
                for doc in docs:
                    # Apply user-configured SON manipulators. This order of
                    # operations is required for backwards compatibility,
                    # see PYTHON-709.
                    doc = _db._apply_incoming_manipulators(doc, self)
                    if not (isinstance(doc, RawBSONDocument) or '_id' in doc):
                        doc['_id'] = ObjectId()

                    doc = _db._apply_incoming_copying_manipulators(doc, self)
                    ids.append(doc['_id'])
                    yield doc
        else:
            def gen():
                """Generator that only tracks existing _ids."""
                for doc in docs:
                    # Don't inflate RawBSONDocument by touching fields.
                    if not isinstance(doc, RawBSONDocument):
                        ids.append(doc.get('_id'))
                    yield doc

        write_concern = write_concern or self._write_concern_for(session)
        blk = _Bulk(self, ordered, bypass_doc_val)
        blk.ops = [(message._INSERT, doc) for doc in gen()]
        try:
            blk.execute(write_concern, session=session)
        except BulkWriteError as bwe:
            _raise_last_error(bwe.details)
        return ids

    def insert_one(self, document, bypass_document_validation=False,
                   session=None):
=======
            acknowledged, _insert_command, session, operation=_Op.INSERT
        )

        if not isinstance(doc, RawBSONDocument):
            return doc.get("_id")
        return None

    def insert_one(
        self,
        document: Union[_DocumentType, RawBSONDocument],
        bypass_document_validation: bool = False,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
    ) -> InsertOneResult:
>>>>>>> origin/master
        """Insert a single document.

          >>> db.test.count_documents({'x': 1})
          0
          >>> result = db.test.insert_one({'x': 1})
          >>> result.inserted_id
          ObjectId('54f112defba522406c9cc208')
          >>> db.test.find_one({'x': 1})
<<<<<<< HEAD
          {u'x': 1, u'_id': ObjectId('54f112defba522406c9cc208')}

        :Parameters:
          - `document`: The document to insert. Must be a mutable mapping
            type. If the document does not have an _id field one will be
            added automatically.
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          - An instance of :class:`~pymongo.results.InsertOneResult`.
=======
          {'x': 1, '_id': ObjectId('54f112defba522406c9cc208')}

        :param document: The document to insert. Must be a mutable mapping
            type. If the document does not have an _id field one will be
            added automatically.
        :param bypass_document_validation: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.

        :return: - An instance of :class:`~pymongo.results.InsertOneResult`.
>>>>>>> origin/master

        .. seealso:: :ref:`writes-and-ids`

        .. note:: `bypass_document_validation` requires server version
          **>= 3.2**

<<<<<<< HEAD
=======
        .. versionchanged:: 4.1
           Added ``comment`` parameter.

>>>>>>> origin/master
        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.2
          Added bypass_document_validation support

        .. versionadded:: 3.0
        """
        common.validate_is_document_type("document", document)
        if not (isinstance(document, RawBSONDocument) or "_id" in document):
<<<<<<< HEAD
            document["_id"] = ObjectId()

        write_concern = self._write_concern_for(session)
        return InsertOneResult(
            self._insert(document,
                         write_concern=write_concern,
                         bypass_doc_val=bypass_document_validation,
                         session=session),
            write_concern.acknowledged)

    def insert_many(self, documents, ordered=True,
                    bypass_document_validation=False, session=None):
=======
            document["_id"] = ObjectId()  # type: ignore[index]

        write_concern = self._write_concern_for(session)
        return InsertOneResult(
            self._insert_one(
                document,
                ordered=True,
                write_concern=write_concern,
                op_id=None,
                bypass_doc_val=bypass_document_validation,
                session=session,
                comment=comment,
            ),
            write_concern.acknowledged,
        )

    @_csot.apply
    def insert_many(
        self,
        documents: Iterable[Union[_DocumentType, RawBSONDocument]],
        ordered: bool = True,
        bypass_document_validation: bool = False,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
    ) -> InsertManyResult:
>>>>>>> origin/master
        """Insert an iterable of documents.

          >>> db.test.count_documents({})
          0
          >>> result = db.test.insert_many([{'x': i} for i in range(2)])
          >>> result.inserted_ids
          [ObjectId('54f113fffba522406c9cc20e'), ObjectId('54f113fffba522406c9cc20f')]
          >>> db.test.count_documents({})
          2

<<<<<<< HEAD
        :Parameters:
          - `documents`: A iterable of documents to insert.
          - `ordered` (optional): If ``True`` (the default) documents will be
=======
        :param documents: A iterable of documents to insert.
        :param ordered: If ``True`` (the default) documents will be
>>>>>>> origin/master
            inserted on the server serially, in the order provided. If an error
            occurs all remaining inserts are aborted. If ``False``, documents
            will be inserted on the server in arbitrary order, possibly in
            parallel, and all document inserts will be attempted.
<<<<<<< HEAD
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          An instance of :class:`~pymongo.results.InsertManyResult`.
=======
        :param bypass_document_validation: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.

        :return: An instance of :class:`~pymongo.results.InsertManyResult`.
>>>>>>> origin/master

        .. seealso:: :ref:`writes-and-ids`

        .. note:: `bypass_document_validation` requires server version
          **>= 3.2**

<<<<<<< HEAD
=======
        .. versionchanged:: 4.1
           Added ``comment`` parameter.

>>>>>>> origin/master
        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.2
          Added bypass_document_validation support

        .. versionadded:: 3.0
        """
<<<<<<< HEAD
        if not isinstance(documents, abc.Iterable) or not documents:
            raise TypeError("documents must be a non-empty list")
        inserted_ids = []
        def gen():
=======
        if (
            not isinstance(documents, abc.Iterable)
            or isinstance(documents, abc.Mapping)
            or not documents
        ):
            raise TypeError("documents must be a non-empty list")
        inserted_ids: list[ObjectId] = []

        def gen() -> Iterator[tuple[int, Mapping[str, Any]]]:
>>>>>>> origin/master
            """A generator that validates documents and handles _ids."""
            for document in documents:
                common.validate_is_document_type("document", document)
                if not isinstance(document, RawBSONDocument):
                    if "_id" not in document:
<<<<<<< HEAD
                        document["_id"] = ObjectId()
=======
                        document["_id"] = ObjectId()  # type: ignore[index]
>>>>>>> origin/master
                    inserted_ids.append(document["_id"])
                yield (message._INSERT, document)

        write_concern = self._write_concern_for(session)
<<<<<<< HEAD
        blk = _Bulk(self, ordered, bypass_document_validation)
        blk.ops = [doc for doc in gen()]
        blk.execute(write_concern, session=session)
        return InsertManyResult(inserted_ids, write_concern.acknowledged)

    def _update(self, sock_info, criteria, document, upsert=False,
                check_keys=True, multi=False, manipulate=False,
                write_concern=None, op_id=None, ordered=True,
                bypass_doc_val=False, collation=None, array_filters=None,
                hint=None, session=None, retryable_write=False):
        """Internal update / replace helper."""
        common.validate_boolean("upsert", upsert)
        if manipulate:
            document = self.__database._fix_incoming(document, self)
        collation = validate_collation_or_none(collation)
        write_concern = write_concern or self.write_concern
        acknowledged = write_concern.acknowledged
        update_doc = SON([('q', criteria),
                          ('u', document),
                          ('multi', multi),
                          ('upsert', upsert)])
        if collation is not None:
            if sock_info.max_wire_version < 5:
                raise ConfigurationError(
                    'Must be connected to MongoDB 3.4+ to use collations.')
            elif not acknowledged:
                raise ConfigurationError(
                    'Collation is unsupported for unacknowledged writes.')
            else:
                update_doc['collation'] = collation
        if array_filters is not None:
            if sock_info.max_wire_version < 6:
                raise ConfigurationError(
                    'Must be connected to MongoDB 3.6+ to use array_filters.')
            elif not acknowledged:
                raise ConfigurationError(
                    'arrayFilters is unsupported for unacknowledged writes.')
            else:
                update_doc['arrayFilters'] = array_filters
        if hint is not None:
            if sock_info.max_wire_version < 5:
                raise ConfigurationError(
                    'Must be connected to MongoDB 3.4+ to use hint.')
            elif not acknowledged:
                raise ConfigurationError(
                    'hint is unsupported for unacknowledged writes.')
            if not isinstance(hint, string_type):
                hint = helpers._index_document(hint)
            update_doc['hint'] = hint

        command = SON([('update', self.name),
                       ('ordered', ordered),
                       ('updates', [update_doc])])
        if not write_concern.is_server_default:
            command['writeConcern'] = write_concern.document

        if not sock_info.op_msg_enabled and not acknowledged:
            # Legacy OP_UPDATE.
            return self._legacy_write(
                sock_info, 'update', command, op_id,
                bypass_doc_val, message.update, self.__full_name, upsert,
                multi, criteria, document, False, write_concern.document,
                check_keys, self.__write_response_codec_options)

        # Update command.
        if bypass_doc_val and sock_info.max_wire_version >= 4:
            command['bypassDocumentValidation'] = True

        # The command result has to be published for APM unmodified
        # so we make a shallow copy here before adding updatedExisting.
        result = sock_info.command(
=======
        blk = _Bulk(self, ordered, bypass_document_validation, comment=comment)
        blk.ops = list(gen())
        blk.execute(write_concern, session, _Op.INSERT)
        return InsertManyResult(inserted_ids, write_concern.acknowledged)

    def _update(
        self,
        conn: Connection,
        criteria: Mapping[str, Any],
        document: Union[Mapping[str, Any], _Pipeline],
        upsert: bool = False,
        multi: bool = False,
        write_concern: Optional[WriteConcern] = None,
        op_id: Optional[int] = None,
        ordered: bool = True,
        bypass_doc_val: Optional[bool] = False,
        collation: Optional[_CollationIn] = None,
        array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        retryable_write: bool = False,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> Optional[Mapping[str, Any]]:
        """Internal update / replace helper."""
        validate_boolean("upsert", upsert)
        collation = validate_collation_or_none(collation)
        write_concern = write_concern or self.write_concern
        acknowledged = write_concern.acknowledged
        update_doc: dict[str, Any] = {
            "q": criteria,
            "u": document,
            "multi": multi,
            "upsert": upsert,
        }
        if collation is not None:
            if not acknowledged:
                raise ConfigurationError("Collation is unsupported for unacknowledged writes.")
            else:
                update_doc["collation"] = collation
        if array_filters is not None:
            if not acknowledged:
                raise ConfigurationError("arrayFilters is unsupported for unacknowledged writes.")
            else:
                update_doc["arrayFilters"] = array_filters
        if hint is not None:
            if not acknowledged and conn.max_wire_version < 8:
                raise ConfigurationError(
                    "Must be connected to MongoDB 4.2+ to use hint on unacknowledged update commands."
                )
            if not isinstance(hint, str):
                hint = helpers._index_document(hint)
            update_doc["hint"] = hint
        command = {"update": self.name, "ordered": ordered, "updates": [update_doc]}
        if let is not None:
            common.validate_is_mapping("let", let)
            command["let"] = let

        if comment is not None:
            command["comment"] = comment
        # Update command.
        if bypass_doc_val:
            command["bypassDocumentValidation"] = True

        # The command result has to be published for APM unmodified
        # so we make a shallow copy here before adding updatedExisting.
        result = conn.command(
>>>>>>> origin/master
            self.__database.name,
            command,
            write_concern=write_concern,
            codec_options=self.__write_response_codec_options,
            session=session,
            client=self.__database.client,
<<<<<<< HEAD
            retryable_write=retryable_write).copy()
        _check_write_command_response(result)
        # Add the updatedExisting field for compatibility.
        if result.get('n') and 'upserted' not in result:
            result['updatedExisting'] = True
        else:
            result['updatedExisting'] = False
            # MongoDB >= 2.6.0 returns the upsert _id in an array
            # element. Break it out for backward compatibility.
            if 'upserted' in result:
                result['upserted'] = result['upserted'][0]['_id']
=======
            retryable_write=retryable_write,
        ).copy()
        _check_write_command_response(result)
        # Add the updatedExisting field for compatibility.
        if result.get("n") and "upserted" not in result:
            result["updatedExisting"] = True
        else:
            result["updatedExisting"] = False
            # MongoDB >= 2.6.0 returns the upsert _id in an array
            # element. Break it out for backward compatibility.
            if "upserted" in result:
                result["upserted"] = result["upserted"][0]["_id"]
>>>>>>> origin/master

        if not acknowledged:
            return None
        return result

    def _update_retryable(
<<<<<<< HEAD
            self, criteria, document, upsert=False,
            check_keys=True, multi=False, manipulate=False,
            write_concern=None, op_id=None, ordered=True,
            bypass_doc_val=False, collation=None, array_filters=None,
            hint=None, session=None):
        """Internal update / replace helper."""
        def _update(session, sock_info, retryable_write):
            return self._update(
                sock_info, criteria, document, upsert=upsert,
                check_keys=check_keys, multi=multi, manipulate=manipulate,
                write_concern=write_concern, op_id=op_id, ordered=ordered,
                bypass_doc_val=bypass_doc_val, collation=collation,
                array_filters=array_filters, hint=hint, session=session,
                retryable_write=retryable_write)

        return self.__database.client._retryable_write(
            (write_concern or self.write_concern).acknowledged and not multi,
            _update, session)

    def replace_one(self, filter, replacement, upsert=False,
                    bypass_document_validation=False, collation=None,
                    hint=None, session=None):
=======
        self,
        criteria: Mapping[str, Any],
        document: Union[Mapping[str, Any], _Pipeline],
        operation: str,
        upsert: bool = False,
        multi: bool = False,
        write_concern: Optional[WriteConcern] = None,
        op_id: Optional[int] = None,
        ordered: bool = True,
        bypass_doc_val: Optional[bool] = False,
        collation: Optional[_CollationIn] = None,
        array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> Optional[Mapping[str, Any]]:
        """Internal update / replace helper."""

        def _update(
            session: Optional[ClientSession], conn: Connection, retryable_write: bool
        ) -> Optional[Mapping[str, Any]]:
            return self._update(
                conn,
                criteria,
                document,
                upsert=upsert,
                multi=multi,
                write_concern=write_concern,
                op_id=op_id,
                ordered=ordered,
                bypass_doc_val=bypass_doc_val,
                collation=collation,
                array_filters=array_filters,
                hint=hint,
                session=session,
                retryable_write=retryable_write,
                let=let,
                comment=comment,
            )

        return self.__database.client._retryable_write(
            (write_concern or self.write_concern).acknowledged and not multi,
            _update,
            session,
            operation,
        )

    def replace_one(
        self,
        filter: Mapping[str, Any],
        replacement: Mapping[str, Any],
        upsert: bool = False,
        bypass_document_validation: bool = False,
        collation: Optional[_CollationIn] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> UpdateResult:
>>>>>>> origin/master
        """Replace a single document matching the filter.

          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': ObjectId('54f4c5befba5220aa4d6dee7')}
=======
          {'x': 1, '_id': ObjectId('54f4c5befba5220aa4d6dee7')}
>>>>>>> origin/master
          >>> result = db.test.replace_one({'x': 1}, {'y': 1})
          >>> result.matched_count
          1
          >>> result.modified_count
          1
          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'y': 1, u'_id': ObjectId('54f4c5befba5220aa4d6dee7')}
=======
          {'y': 1, '_id': ObjectId('54f4c5befba5220aa4d6dee7')}
>>>>>>> origin/master

        The *upsert* option can be used to insert a new document if a matching
        document does not exist.

          >>> result = db.test.replace_one({'x': 1}, {'x': 1}, True)
          >>> result.matched_count
          0
          >>> result.modified_count
          0
          >>> result.upserted_id
          ObjectId('54f11e5c8891e756a6e1abd4')
          >>> db.test.find_one({'x': 1})
<<<<<<< HEAD
          {u'x': 1, u'_id': ObjectId('54f11e5c8891e756a6e1abd4')}

        :Parameters:
          - `filter`: A query that matches the document to replace.
          - `replacement`: The new document.
          - `upsert` (optional): If ``True``, perform an insert if no documents
            match the filter.
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``. This option is only supported on MongoDB 3.2 and above.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `hint` (optional): An index to use to support the query
=======
          {'x': 1, '_id': ObjectId('54f11e5c8891e756a6e1abd4')}

        :param filter: A query that matches the document to replace.
        :param replacement: The new document.
        :param upsert: If ``True``, perform an insert if no documents
            match the filter.
        :param bypass_document_validation: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`.
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.2 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          - An instance of :class:`~pymongo.results.UpdateResult`.

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.
        :return: - An instance of :class:`~pymongo.results.UpdateResult`.

        .. versionchanged:: 4.1
           Added ``let`` parameter.
           Added ``comment`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added ``hint`` parameter.
        .. versionchanged:: 3.6
           Added ``session`` parameter.
        .. versionchanged:: 3.4
          Added the `collation` option.
        .. versionchanged:: 3.2
          Added bypass_document_validation support.

        .. versionadded:: 3.0
        """
        common.validate_is_mapping("filter", filter)
        common.validate_ok_for_replace(replacement)
<<<<<<< HEAD

        write_concern = self._write_concern_for(session)
        return UpdateResult(
            self._update_retryable(
                filter, replacement, upsert,
                write_concern=write_concern,
                bypass_doc_val=bypass_document_validation,
                collation=collation, hint=hint, session=session),
            write_concern.acknowledged)

    def update_one(self, filter, update, upsert=False,
                   bypass_document_validation=False,
                   collation=None, array_filters=None, hint=None,
                   session=None):
=======
        if let is not None:
            common.validate_is_mapping("let", let)
        write_concern = self._write_concern_for(session)
        return UpdateResult(
            self._update_retryable(
                filter,
                replacement,
                _Op.UPDATE,
                upsert,
                write_concern=write_concern,
                bypass_doc_val=bypass_document_validation,
                collation=collation,
                hint=hint,
                session=session,
                let=let,
                comment=comment,
            ),
            write_concern.acknowledged,
        )

    def update_one(
        self,
        filter: Mapping[str, Any],
        update: Union[Mapping[str, Any], _Pipeline],
        upsert: bool = False,
        bypass_document_validation: bool = False,
        collation: Optional[_CollationIn] = None,
        array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> UpdateResult:
>>>>>>> origin/master
        """Update a single document matching the filter.

          >>> for doc in db.test.find():
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': 0}
          {u'x': 1, u'_id': 1}
          {u'x': 1, u'_id': 2}
=======
          {'x': 1, '_id': 0}
          {'x': 1, '_id': 1}
          {'x': 1, '_id': 2}
>>>>>>> origin/master
          >>> result = db.test.update_one({'x': 1}, {'$inc': {'x': 3}})
          >>> result.matched_count
          1
          >>> result.modified_count
          1
          >>> for doc in db.test.find():
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 4, u'_id': 0}
          {u'x': 1, u'_id': 1}
          {u'x': 1, u'_id': 2}

        :Parameters:
          - `filter`: A query that matches the document to update.
          - `update`: The modifications to apply.
          - `upsert` (optional): If ``True``, perform an insert if no documents
            match the filter.
          - `bypass_document_validation`: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``. This option is only supported on MongoDB 3.2 and above.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `array_filters` (optional): A list of filters specifying which
            array elements an update should apply. This option is only
            supported on MongoDB 3.6 and above.
          - `hint` (optional): An index to use to support the query
=======
          {'x': 4, '_id': 0}
          {'x': 1, '_id': 1}
          {'x': 1, '_id': 2}

        If ``upsert=True`` and no documents match the filter, create a
        new document based on the filter criteria and update modifications.

          >>> result = db.test.update_one({'x': -10}, {'$inc': {'x': 3}}, upsert=True)
          >>> result.matched_count
          0
          >>> result.modified_count
          0
          >>> result.upserted_id
          ObjectId('626a678eeaa80587d4bb3fb7')
          >>> db.test.find_one(result.upserted_id)
          {'_id': ObjectId('626a678eeaa80587d4bb3fb7'), 'x': -7}

        :param filter: A query that matches the document to update.
        :param update: The modifications to apply.
        :param upsert: If ``True``, perform an insert if no documents
            match the filter.
        :param bypass_document_validation: (optional) If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`.
        :param array_filters: A list of filters specifying which
            array elements an update should apply.
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.2 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          - An instance of :class:`~pymongo.results.UpdateResult`.

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.

        :return: - An instance of :class:`~pymongo.results.UpdateResult`.

        .. versionchanged:: 4.1
           Added ``let`` parameter.
           Added ``comment`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added ``hint`` parameter.
        .. versionchanged:: 3.9
           Added the ability to accept a pipeline as the ``update``.
        .. versionchanged:: 3.6
           Added the ``array_filters`` and ``session`` parameters.
        .. versionchanged:: 3.4
          Added the ``collation`` option.
        .. versionchanged:: 3.2
          Added ``bypass_document_validation`` support.

        .. versionadded:: 3.0
        """
        common.validate_is_mapping("filter", filter)
        common.validate_ok_for_update(update)
<<<<<<< HEAD
        common.validate_list_or_none('array_filters', array_filters)
=======
        common.validate_list_or_none("array_filters", array_filters)
>>>>>>> origin/master

        write_concern = self._write_concern_for(session)
        return UpdateResult(
            self._update_retryable(
<<<<<<< HEAD
                filter, update, upsert, check_keys=False,
                write_concern=write_concern,
                bypass_doc_val=bypass_document_validation,
                collation=collation, array_filters=array_filters,
                hint=hint, session=session),
            write_concern.acknowledged)

    def update_many(self, filter, update, upsert=False, array_filters=None,
                    bypass_document_validation=False, collation=None,
                    hint=None, session=None):
=======
                filter,
                update,
                _Op.UPDATE,
                upsert,
                write_concern=write_concern,
                bypass_doc_val=bypass_document_validation,
                collation=collation,
                array_filters=array_filters,
                hint=hint,
                session=session,
                let=let,
                comment=comment,
            ),
            write_concern.acknowledged,
        )

    def update_many(
        self,
        filter: Mapping[str, Any],
        update: Union[Mapping[str, Any], _Pipeline],
        upsert: bool = False,
        array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
        bypass_document_validation: Optional[bool] = None,
        collation: Optional[_CollationIn] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> UpdateResult:
>>>>>>> origin/master
        """Update one or more documents that match the filter.

          >>> for doc in db.test.find():
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': 0}
          {u'x': 1, u'_id': 1}
          {u'x': 1, u'_id': 2}
=======
          {'x': 1, '_id': 0}
          {'x': 1, '_id': 1}
          {'x': 1, '_id': 2}
>>>>>>> origin/master
          >>> result = db.test.update_many({'x': 1}, {'$inc': {'x': 3}})
          >>> result.matched_count
          3
          >>> result.modified_count
          3
          >>> for doc in db.test.find():
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 4, u'_id': 0}
          {u'x': 4, u'_id': 1}
          {u'x': 4, u'_id': 2}

        :Parameters:
          - `filter`: A query that matches the documents to update.
          - `update`: The modifications to apply.
          - `upsert` (optional): If ``True``, perform an insert if no documents
            match the filter.
          - `bypass_document_validation` (optional): If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``. This option is only supported on MongoDB 3.2 and above.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `array_filters` (optional): A list of filters specifying which
            array elements an update should apply. This option is only
            supported on MongoDB 3.6 and above.
          - `hint` (optional): An index to use to support the query
=======
          {'x': 4, '_id': 0}
          {'x': 4, '_id': 1}
          {'x': 4, '_id': 2}

        :param filter: A query that matches the documents to update.
        :param update: The modifications to apply.
        :param upsert: If ``True``, perform an insert if no documents
            match the filter.
        :param bypass_document_validation: If ``True``, allows the
            write to opt-out of document level validation. Default is
            ``False``.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`.
        :param array_filters: A list of filters specifying which
            array elements an update should apply.
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.2 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          - An instance of :class:`~pymongo.results.UpdateResult`.

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.

        :return: - An instance of :class:`~pymongo.results.UpdateResult`.

        .. versionchanged:: 4.1
           Added ``let`` parameter.
           Added ``comment`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added ``hint`` parameter.
        .. versionchanged:: 3.9
           Added the ability to accept a pipeline as the `update`.
        .. versionchanged:: 3.6
           Added ``array_filters`` and ``session`` parameters.
        .. versionchanged:: 3.4
          Added the `collation` option.
        .. versionchanged:: 3.2
          Added bypass_document_validation support.

        .. versionadded:: 3.0
        """
        common.validate_is_mapping("filter", filter)
        common.validate_ok_for_update(update)
<<<<<<< HEAD
        common.validate_list_or_none('array_filters', array_filters)
=======
        common.validate_list_or_none("array_filters", array_filters)
>>>>>>> origin/master

        write_concern = self._write_concern_for(session)
        return UpdateResult(
            self._update_retryable(
<<<<<<< HEAD
                filter, update, upsert, check_keys=False, multi=True,
                write_concern=write_concern,
                bypass_doc_val=bypass_document_validation,
                collation=collation, array_filters=array_filters,
                hint=hint, session=session),
            write_concern.acknowledged)

    def drop(self, session=None):
        """Alias for :meth:`~pymongo.database.Database.drop_collection`.

        :Parameters:
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
=======
                filter,
                update,
                _Op.UPDATE,
                upsert,
                multi=True,
                write_concern=write_concern,
                bypass_doc_val=bypass_document_validation,
                collation=collation,
                array_filters=array_filters,
                hint=hint,
                session=session,
                let=let,
                comment=comment,
            ),
            write_concern.acknowledged,
        )

    def drop(
        self,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        encrypted_fields: Optional[Mapping[str, Any]] = None,
    ) -> None:
        """Alias for :meth:`~pymongo.database.Database.drop_collection`.

        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param encrypted_fields: **(BETA)** Document that describes the encrypted fields for
            Queryable Encryption.
>>>>>>> origin/master

        The following two calls are equivalent:

          >>> db.foo.drop()
          >>> db.drop_collection("foo")

<<<<<<< HEAD
=======
        .. versionchanged:: 4.2
           Added ``encrypted_fields`` parameter.

        .. versionchanged:: 4.1
           Added ``comment`` parameter.

>>>>>>> origin/master
        .. versionchanged:: 3.7
           :meth:`drop` now respects this :class:`Collection`'s :attr:`write_concern`.

        .. versionchanged:: 3.6
           Added ``session`` parameter.
        """
        dbo = self.__database.client.get_database(
            self.__database.name,
            self.codec_options,
            self.read_preference,
            self.write_concern,
<<<<<<< HEAD
            self.read_concern)
        dbo.drop_collection(self.__name, session=session)

    def _delete(
            self, sock_info, criteria, multi,
            write_concern=None, op_id=None, ordered=True,
            collation=None, hint=None, session=None, retryable_write=False):
=======
            self.read_concern,
        )
        dbo.drop_collection(
            self.__name, session=session, comment=comment, encrypted_fields=encrypted_fields
        )

    def _delete(
        self,
        conn: Connection,
        criteria: Mapping[str, Any],
        multi: bool,
        write_concern: Optional[WriteConcern] = None,
        op_id: Optional[int] = None,
        ordered: bool = True,
        collation: Optional[_CollationIn] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        retryable_write: bool = False,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> Mapping[str, Any]:
>>>>>>> origin/master
        """Internal delete helper."""
        common.validate_is_mapping("filter", criteria)
        write_concern = write_concern or self.write_concern
        acknowledged = write_concern.acknowledged
<<<<<<< HEAD
        delete_doc = SON([('q', criteria),
                          ('limit', int(not multi))])
        collation = validate_collation_or_none(collation)
        if collation is not None:
            if sock_info.max_wire_version < 5:
                raise ConfigurationError(
                    'Must be connected to MongoDB 3.4+ to use collations.')
            elif not acknowledged:
                raise ConfigurationError(
                    'Collation is unsupported for unacknowledged writes.')
            else:
                delete_doc['collation'] = collation
        if hint is not None:
            if sock_info.max_wire_version < 5:
                raise ConfigurationError(
                    'Must be connected to MongoDB 3.4+ to use hint.')
            elif not acknowledged:
                raise ConfigurationError(
                    'hint is unsupported for unacknowledged writes.')
            if not isinstance(hint, string_type):
                hint = helpers._index_document(hint)
            delete_doc['hint'] = hint
        command = SON([('delete', self.name),
                       ('ordered', ordered),
                       ('deletes', [delete_doc])])
        if not write_concern.is_server_default:
            command['writeConcern'] = write_concern.document

        if not sock_info.op_msg_enabled and not acknowledged:
            # Legacy OP_DELETE.
            return self._legacy_write(
                sock_info, 'delete', command, op_id,
                False, message.delete, self.__full_name, criteria,
                False, write_concern.document,
                self.__write_response_codec_options,
                int(not multi))
        # Delete command.
        result = sock_info.command(
=======
        delete_doc = {"q": criteria, "limit": int(not multi)}
        collation = validate_collation_or_none(collation)
        if collation is not None:
            if not acknowledged:
                raise ConfigurationError("Collation is unsupported for unacknowledged writes.")
            else:
                delete_doc["collation"] = collation
        if hint is not None:
            if not acknowledged and conn.max_wire_version < 9:
                raise ConfigurationError(
                    "Must be connected to MongoDB 4.4+ to use hint on unacknowledged delete commands."
                )
            if not isinstance(hint, str):
                hint = helpers._index_document(hint)
            delete_doc["hint"] = hint
        command = {"delete": self.name, "ordered": ordered, "deletes": [delete_doc]}

        if let is not None:
            common.validate_is_document_type("let", let)
            command["let"] = let

        if comment is not None:
            command["comment"] = comment

        # Delete command.
        result = conn.command(
>>>>>>> origin/master
            self.__database.name,
            command,
            write_concern=write_concern,
            codec_options=self.__write_response_codec_options,
            session=session,
            client=self.__database.client,
<<<<<<< HEAD
            retryable_write=retryable_write)
=======
            retryable_write=retryable_write,
        )
>>>>>>> origin/master
        _check_write_command_response(result)
        return result

    def _delete_retryable(
<<<<<<< HEAD
            self, criteria, multi,
            write_concern=None, op_id=None, ordered=True,
            collation=None, hint=None, session=None):
        """Internal delete helper."""
        def _delete(session, sock_info, retryable_write):
            return self._delete(
                sock_info, criteria, multi,
                write_concern=write_concern, op_id=op_id, ordered=ordered,
                collation=collation, hint=hint, session=session,
                retryable_write=retryable_write)

        return self.__database.client._retryable_write(
            (write_concern or self.write_concern).acknowledged and not multi,
            _delete, session)

    def delete_one(self, filter, collation=None, hint=None, session=None):
=======
        self,
        criteria: Mapping[str, Any],
        multi: bool,
        write_concern: Optional[WriteConcern] = None,
        op_id: Optional[int] = None,
        ordered: bool = True,
        collation: Optional[_CollationIn] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> Mapping[str, Any]:
        """Internal delete helper."""

        def _delete(
            session: Optional[ClientSession], conn: Connection, retryable_write: bool
        ) -> Mapping[str, Any]:
            return self._delete(
                conn,
                criteria,
                multi,
                write_concern=write_concern,
                op_id=op_id,
                ordered=ordered,
                collation=collation,
                hint=hint,
                session=session,
                retryable_write=retryable_write,
                let=let,
                comment=comment,
            )

        return self.__database.client._retryable_write(
            (write_concern or self.write_concern).acknowledged and not multi,
            _delete,
            session,
            operation=_Op.DELETE,
        )

    def delete_one(
        self,
        filter: Mapping[str, Any],
        collation: Optional[_CollationIn] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> DeleteResult:
>>>>>>> origin/master
        """Delete a single document matching the filter.

          >>> db.test.count_documents({'x': 1})
          3
          >>> result = db.test.delete_one({'x': 1})
          >>> result.deleted_count
          1
          >>> db.test.count_documents({'x': 1})
          2

<<<<<<< HEAD
        :Parameters:
          - `filter`: A query that matches the document to delete.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `hint` (optional): An index to use to support the query
=======
        :param filter: A query that matches the document to delete.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`.
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.4 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          - An instance of :class:`~pymongo.results.DeleteResult`.

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.

        :return: - An instance of :class:`~pymongo.results.DeleteResult`.

        .. versionchanged:: 4.1
           Added ``let`` parameter.
           Added ``comment`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added ``hint`` parameter.
        .. versionchanged:: 3.6
           Added ``session`` parameter.
        .. versionchanged:: 3.4
          Added the `collation` option.
        .. versionadded:: 3.0
        """
        write_concern = self._write_concern_for(session)
        return DeleteResult(
            self._delete_retryable(
<<<<<<< HEAD
                filter, False,
                write_concern=write_concern,
                collation=collation, hint=hint, session=session),
            write_concern.acknowledged)

    def delete_many(self, filter, collation=None, hint=None, session=None):
=======
                filter,
                False,
                write_concern=write_concern,
                collation=collation,
                hint=hint,
                session=session,
                let=let,
                comment=comment,
            ),
            write_concern.acknowledged,
        )

    def delete_many(
        self,
        filter: Mapping[str, Any],
        collation: Optional[_CollationIn] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
    ) -> DeleteResult:
>>>>>>> origin/master
        """Delete one or more documents matching the filter.

          >>> db.test.count_documents({'x': 1})
          3
          >>> result = db.test.delete_many({'x': 1})
          >>> result.deleted_count
          3
          >>> db.test.count_documents({'x': 1})
          0

<<<<<<< HEAD
        :Parameters:
          - `filter`: A query that matches the documents to delete.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `hint` (optional): An index to use to support the query
=======
        :param filter: A query that matches the documents to delete.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`.
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.4 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          - An instance of :class:`~pymongo.results.DeleteResult`.

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.

        :return: - An instance of :class:`~pymongo.results.DeleteResult`.

        .. versionchanged:: 4.1
           Added ``let`` parameter.
           Added ``comment`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added ``hint`` parameter.
        .. versionchanged:: 3.6
           Added ``session`` parameter.
        .. versionchanged:: 3.4
          Added the `collation` option.
        .. versionadded:: 3.0
        """
        write_concern = self._write_concern_for(session)
        return DeleteResult(
            self._delete_retryable(
<<<<<<< HEAD
                filter, True,
                write_concern=write_concern,
                collation=collation, hint=hint, session=session),
            write_concern.acknowledged)

    def find_one(self, filter=None, *args, **kwargs):
=======
                filter,
                True,
                write_concern=write_concern,
                collation=collation,
                hint=hint,
                session=session,
                let=let,
                comment=comment,
            ),
            write_concern.acknowledged,
        )

    def find_one(
        self, filter: Optional[Any] = None, *args: Any, **kwargs: Any
    ) -> Optional[_DocumentType]:
>>>>>>> origin/master
        """Get a single document from the database.

        All arguments to :meth:`find` are also valid arguments for
        :meth:`find_one`, although any `limit` argument will be
        ignored. Returns a single document, or ``None`` if no matching
        document is found.

        The :meth:`find_one` method obeys the :attr:`read_preference` of
        this :class:`Collection`.

<<<<<<< HEAD
        :Parameters:

          - `filter` (optional): a dictionary specifying
            the query to be performed OR any other type to be used as
            the value for a query for ``"_id"``.

          - `*args` (optional): any additional positional arguments
            are the same as the arguments to :meth:`find`.

          - `**kwargs` (optional): any additional keyword arguments
            are the same as the arguments to :meth:`find`.

              >>> collection.find_one(max_time_ms=100)
        """
        if (filter is not None and not
                isinstance(filter, abc.Mapping)):
            filter = {"_id": filter}

=======
        :param filter: a dictionary specifying
            the query to be performed OR any other type to be used as
            the value for a query for ``"_id"``.

        :param args: any additional positional arguments
            are the same as the arguments to :meth:`find`.

        :param kwargs: any additional keyword arguments
            are the same as the arguments to :meth:`find`.

            :: code-block: python

              >>> collection.find_one(max_time_ms=100)

        """
        if filter is not None and not isinstance(filter, abc.Mapping):
            filter = {"_id": filter}
>>>>>>> origin/master
        cursor = self.find(filter, *args, **kwargs)
        for result in cursor.limit(-1):
            return result
        return None

<<<<<<< HEAD
    def find(self, *args, **kwargs):
        """Query the database.

        The `filter` argument is a prototype document that all results
=======
    def find(self, *args: Any, **kwargs: Any) -> Cursor[_DocumentType]:
        """Query the database.

        The `filter` argument is a query document that all results
>>>>>>> origin/master
        must match. For example:

        >>> db.test.find({"hello": "world"})

        only matches documents that have a key "hello" with value
        "world".  Matches can have other keys *in addition* to
        "hello". The `projection` argument is used to specify a subset
        of fields that should be included in the result documents. By
        limiting results to a certain subset of fields you can cut
        down on network traffic and decoding time.

        Raises :class:`TypeError` if any of the arguments are of
        improper type. Returns an instance of
        :class:`~pymongo.cursor.Cursor` corresponding to this query.

        The :meth:`find` method obeys the :attr:`read_preference` of
        this :class:`Collection`.

<<<<<<< HEAD
        :Parameters:
          - `filter` (optional): a SON object specifying elements which
            must be present for a document to be included in the
            result set
          - `projection` (optional): a list of field names that should be
=======
        :param filter: A query document that selects which documents
            to include in the result set. Can be an empty document to include
            all documents.
        :param projection: a list of field names that should be
>>>>>>> origin/master
            returned in the result set or a dict specifying the fields
            to include or exclude. If `projection` is a list "_id" will
            always be returned. Use a dict to exclude fields from
            the result (e.g. projection={'_id': False}).
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `skip` (optional): the number of documents to omit (from
            the start of the result set) when returning the results
          - `limit` (optional): the maximum number of results to
            return. A limit of 0 (the default) is equivalent to setting no
            limit.
          - `no_cursor_timeout` (optional): if False (the default), any
=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param skip: the number of documents to omit (from
            the start of the result set) when returning the results
        :param limit: the maximum number of results to
            return. A limit of 0 (the default) is equivalent to setting no
            limit.
        :param no_cursor_timeout: if False (the default), any
>>>>>>> origin/master
            returned cursor is closed by the server after 10 minutes of
            inactivity. If set to True, the returned cursor will never
            time out on the server. Care should be taken to ensure that
            cursors with no_cursor_timeout turned on are properly closed.
<<<<<<< HEAD
          - `cursor_type` (optional): the type of cursor to return. The valid
=======
        :param cursor_type: the type of cursor to return. The valid
>>>>>>> origin/master
            options are defined by :class:`~pymongo.cursor.CursorType`:

            - :attr:`~pymongo.cursor.CursorType.NON_TAILABLE` - the result of
              this find call will return a standard cursor over the result set.
            - :attr:`~pymongo.cursor.CursorType.TAILABLE` - the result of this
              find call will be a tailable cursor - tailable cursors are only
              for use with capped collections. They are not closed when the
              last data is retrieved but are kept open and the cursor location
              marks the final document position. If more data is received
              iteration of the cursor will continue from the last document
              received. For details, see the `tailable cursor documentation
<<<<<<< HEAD
              <http://www.mongodb.org/display/DOCS/Tailable+Cursors>`_.
=======
              <https://www.mongodb.com/docs/manual/core/tailable-cursors/>`_.
>>>>>>> origin/master
            - :attr:`~pymongo.cursor.CursorType.TAILABLE_AWAIT` - the result
              of this find call will be a tailable cursor with the await flag
              set. The server will wait for a few seconds after returning the
              full result set so that it can capture and return additional data
              added during the query.
            - :attr:`~pymongo.cursor.CursorType.EXHAUST` - the result of this
              find call will be an exhaust cursor. MongoDB will stream batched
              results to the client without waiting for the client to request
              each batch, reducing latency. See notes on compatibility below.

<<<<<<< HEAD
          - `sort` (optional): a list of (key, direction) pairs
            specifying the sort order for this query. See
            :meth:`~pymongo.cursor.Cursor.sort` for details.
          - `allow_partial_results` (optional): if True, mongos will return
            partial results if some shards are down instead of returning an
            error.
          - `oplog_replay` (optional): **DEPRECATED** - if True, set the
            oplogReplay query flag. Default: False.
          - `batch_size` (optional): Limits the number of documents returned in
            a single batch.
          - `manipulate` (optional): **DEPRECATED** - If True, apply any
            outgoing SON manipulators before returning. Default: True.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `return_key` (optional): If True, return only the index keys in
            each document.
          - `show_record_id` (optional): If True, adds a field ``$recordId`` in
            each document with the storage engine's internal record identifier.
          - `snapshot` (optional): **DEPRECATED** - If True, prevents the
            cursor from returning a document more than once because of an
            intervening write operation.
          - `hint` (optional): An index, in the same format as passed to
=======
        :param sort: a list of (key, direction) pairs
            specifying the sort order for this query. See
            :meth:`~pymongo.cursor.Cursor.sort` for details.
        :param allow_partial_results: if True, mongos will return
            partial results if some shards are down instead of returning an
            error.
        :param oplog_replay: **DEPRECATED** - if True, set the
            oplogReplay query flag. Default: False.
        :param batch_size: Limits the number of documents returned in
            a single batch.
        :param collation: An instance of
            :class:`~pymongo.collation.Collation`.
        :param return_key: If True, return only the index keys in
            each document.
        :param show_record_id: If True, adds a field ``$recordId`` in
            each document with the storage engine's internal record identifier.
        :param snapshot: **DEPRECATED** - If True, prevents the
            cursor from returning a document more than once because of an
            intervening write operation.
        :param hint: An index, in the same format as passed to
>>>>>>> origin/master
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.hint` on the cursor to tell Mongo the
            proper index to use for the query.
<<<<<<< HEAD
          - `max_time_ms` (optional): Specifies a time limit for a query
=======
        :param max_time_ms: Specifies a time limit for a query
>>>>>>> origin/master
            operation. If the specified time is exceeded, the operation will be
            aborted and :exc:`~pymongo.errors.ExecutionTimeout` is raised. Pass
            this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.max_time_ms` on the cursor.
<<<<<<< HEAD
          - `max_scan` (optional): **DEPRECATED** - The maximum number of
            documents to scan. Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.max_scan` on the cursor.
          - `min` (optional): A list of field, limit pairs specifying the
=======
        :param max_scan: **DEPRECATED** - The maximum number of
            documents to scan. Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.max_scan` on the cursor.
        :param min: A list of field, limit pairs specifying the
>>>>>>> origin/master
            inclusive lower bound for all keys of a specific index in order.
            Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.min` on the cursor. ``hint`` must
            also be passed to ensure the query utilizes the correct index.
<<<<<<< HEAD
          - `max` (optional): A list of field, limit pairs specifying the
=======
        :param max: A list of field, limit pairs specifying the
>>>>>>> origin/master
            exclusive upper bound for all keys of a specific index in order.
            Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.max` on the cursor. ``hint`` must
            also be passed to ensure the query utilizes the correct index.
<<<<<<< HEAD
          - `comment` (optional): A string to attach to the query to help
            interpret and trace the operation in the server logs and in profile
            data. Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.comment` on the cursor.
          - `modifiers` (optional): **DEPRECATED** - A dict specifying
            additional MongoDB query modifiers. Use the keyword arguments listed
            above instead.
          - `allow_disk_use` (optional): if True, MongoDB may use temporary
=======
        :param comment: A string to attach to the query to help
            interpret and trace the operation in the server logs and in profile
            data. Pass this as an alternative to calling
            :meth:`~pymongo.cursor.Cursor.comment` on the cursor.
        :param allow_disk_use: if True, MongoDB may use temporary
>>>>>>> origin/master
            disk files to store data exceeding the system memory limit while
            processing a blocking sort operation. The option has no effect if
            MongoDB can satisfy the specified sort using an index, or if the
            blocking sort requires less memory than the 100 MiB limit. This
            option is only supported on MongoDB 4.4 and above.

        .. note:: There are a number of caveats to using
          :attr:`~pymongo.cursor.CursorType.EXHAUST` as cursor_type:

          - The `limit` option can not be used with an exhaust cursor.

          - Exhaust cursors are not supported by mongos and can not be
            used with a sharded cluster.

          - A :class:`~pymongo.cursor.Cursor` instance created with the
            :attr:`~pymongo.cursor.CursorType.EXHAUST` cursor_type requires an
            exclusive :class:`~socket.socket` connection to MongoDB. If the
            :class:`~pymongo.cursor.Cursor` is discarded without being
            completely iterated the underlying :class:`~socket.socket`
            connection will be closed and discarded without being returned to
            the connection pool.

<<<<<<< HEAD
=======
        .. versionchanged:: 4.0
           Removed the ``modifiers`` option.
           Empty projections (eg {} or []) are passed to the server as-is,
           rather than the previous behavior which substituted in a
           projection of ``{"_id": 1}``. This means that an empty projection
           will now return the entire document, not just the ``"_id"`` field.

>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added the ``allow_disk_use`` option.
           Deprecated the ``oplog_replay`` option. Support for this option is
           deprecated in MongoDB 4.4. The query engine now automatically
           optimizes queries against the oplog without requiring this
           option to be set.

        .. versionchanged:: 3.7
           Deprecated the ``snapshot`` option, which is deprecated in MongoDB
           3.6 and removed in MongoDB 4.0.
           Deprecated the ``max_scan`` option. Support for this option is
           deprecated in MongoDB 4.0. Use ``max_time_ms`` instead to limit
           server-side execution time.

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.5
           Added the options ``return_key``, ``show_record_id``, ``snapshot``,
           ``hint``, ``max_time_ms``, ``max_scan``, ``min``, ``max``, and
           ``comment``.
           Deprecated the ``modifiers`` option.

        .. versionchanged:: 3.4
           Added support for the ``collation`` option.

        .. versionchanged:: 3.0
           Changed the parameter names ``spec``, ``fields``, ``timeout``, and
           ``partial`` to ``filter``, ``projection``, ``no_cursor_timeout``,
           and ``allow_partial_results`` respectively.
           Added the ``cursor_type``, ``oplog_replay``, and ``modifiers``
           options.
           Removed the ``network_timeout``, ``read_preference``, ``tag_sets``,
           ``secondary_acceptable_latency_ms``, ``max_scan``, ``snapshot``,
           ``tailable``, ``await_data``, ``exhaust``, ``as_class``, and
           slave_okay parameters.
           Removed ``compile_re`` option: PyMongo now always
           represents BSON regular expressions as :class:`~bson.regex.Regex`
           objects. Use :meth:`~bson.regex.Regex.try_compile` to attempt to
           convert from a BSON regular expression to a Python regular
           expression object.
           Soft deprecated the ``manipulate`` option.

<<<<<<< HEAD
        .. versionchanged:: 2.7
           Added ``compile_re`` option. If set to False, PyMongo represented
           BSON regular expressions as :class:`~bson.regex.Regex` objects
           instead of attempting to compile BSON regular expressions as Python
           native regular expressions, thus preventing errors for some
           incompatible patterns, see `PYTHON-500`_.

        .. versionchanged:: 2.3
           Added the ``tag_sets`` and ``secondary_acceptable_latency_ms``
           parameters.

        .. _PYTHON-500: https://jira.mongodb.org/browse/PYTHON-500

        .. mongodoc:: find

        """
        return Cursor(self, *args, **kwargs)

    def find_raw_batches(self, *args, **kwargs):
=======
        .. seealso:: The MongoDB documentation on `find <https://dochub.mongodb.org/core/find>`_.
        """
        return Cursor(self, *args, **kwargs)

    def find_raw_batches(self, *args: Any, **kwargs: Any) -> RawBatchCursor[_DocumentType]:
>>>>>>> origin/master
        """Query the database and retrieve batches of raw BSON.

        Similar to the :meth:`find` method but returns a
        :class:`~pymongo.cursor.RawBatchCursor`.

        This example demonstrates how to work with raw batches, but in practice
        raw batches should be passed to an external library that can decode
        BSON into another data type, rather than used with PyMongo's
        :mod:`bson` module.

          >>> import bson
          >>> cursor = db.test.find_raw_batches()
          >>> for batch in cursor:
          ...     print(bson.decode_all(batch))

<<<<<<< HEAD
        .. note:: find_raw_batches does not support sessions or auto
           encryption.

        .. versionadded:: 3.6
        """
        # OP_MSG with document stream returns is required to support
        # sessions.
        if "session" in kwargs:
            raise ConfigurationError(
                "find_raw_batches does not support sessions")

        # OP_MSG is required to support encryption.
        if self.__database.client._encrypter:
            raise InvalidOperation(
                "find_raw_batches does not support auto encryption")

        return RawBatchCursor(self, *args, **kwargs)

    def parallel_scan(self, num_cursors, session=None, **kwargs):
        """**DEPRECATED**: Scan this entire collection in parallel.

        Returns a list of up to ``num_cursors`` cursors that can be iterated
        concurrently. As long as the collection is not modified during
        scanning, each document appears once in one of the cursors result
        sets.

        For example, to process each document in a collection using some
        thread-safe ``process_document()`` function:

          >>> def process_cursor(cursor):
          ...     for document in cursor:
          ...     # Some thread-safe processing function:
          ...     process_document(document)
          >>>
          >>> # Get up to 4 cursors.
          ...
          >>> cursors = collection.parallel_scan(4)
          >>> threads = [
          ...     threading.Thread(target=process_cursor, args=(cursor,))
          ...     for cursor in cursors]
          >>>
          >>> for thread in threads:
          ...     thread.start()
          >>>
          >>> for thread in threads:
          ...     thread.join()
          >>>
          >>> # All documents have now been processed.

        The :meth:`parallel_scan` method obeys the :attr:`read_preference` of
        this :class:`Collection`.

        :Parameters:
          - `num_cursors`: the number of cursors to return
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs`: additional options for the parallelCollectionScan
            command can be passed as keyword arguments.

        .. note:: Requires server version **>= 2.5.5**.

        .. versionchanged:: 3.7
           Deprecated.

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.4
           Added back support for arbitrary keyword arguments. MongoDB 3.4
           adds support for maxTimeMS as an option to the
           parallelCollectionScan command.

        .. versionchanged:: 3.0
           Removed support for arbitrary keyword arguments, since
           the parallelCollectionScan command has no optional arguments.
        """
        warnings.warn("parallel_scan is deprecated. MongoDB 4.2 will remove "
                      "the parallelCollectionScan command.",
                      DeprecationWarning, stacklevel=2)
        cmd = SON([('parallelCollectionScan', self.__name),
                   ('numCursors', num_cursors)])
        cmd.update(kwargs)

        with self._socket_for_reads(session) as (sock_info, slave_ok):
            # We call sock_info.command here directly, instead of
            # calling self._command to avoid using an implicit session.
            result = sock_info.command(
                self.__database.name,
                cmd,
                slave_ok,
                self._read_preference_for(session),
                self.codec_options,
                read_concern=self.read_concern,
                parse_write_concern_error=True,
                session=session,
                client=self.__database.client)

        cursors = []
        for cursor in result['cursors']:
            cursors.append(CommandCursor(
                self, cursor['cursor'], sock_info.address,
                session=session, explicit_session=session is not None))

        return cursors

    def _count(self, cmd, collation=None, session=None):
        """Internal count helper."""
        # XXX: "ns missing" checks can be removed when we drop support for
        # MongoDB 3.0, see SERVER-17051.
        def _cmd(session, server, sock_info, slave_ok):
            res = self._command(
                sock_info,
                cmd,
                slave_ok,
                allowable_errors=["ns missing"],
                codec_options=self.__write_response_codec_options,
                read_concern=self.read_concern,
                collation=collation,
                session=session)
            if res.get("errmsg", "") == "ns missing":
                return 0
            return int(res["n"])

        return self.__database.client._retryable_read(
            _cmd, self._read_preference_for(session), session)

    def _aggregate_one_result(
            self, sock_info, slave_ok, cmd, collation=None, session=None):
        """Internal helper to run an aggregate that returns a single result."""
        result = self._command(
            sock_info,
            cmd,
            slave_ok,
            codec_options=self.__write_response_codec_options,
            read_concern=self.read_concern,
            collation=collation,
            session=session)
        batch = result['cursor']['firstBatch']
        return batch[0] if batch else None

    def estimated_document_count(self, **kwargs):
=======
        .. note:: find_raw_batches does not support auto encryption.

        .. versionchanged:: 3.12
           Instead of ignoring the user-specified read concern, this method
           now sends it to the server when connected to MongoDB 3.6+.

           Added session support.

        .. versionadded:: 3.6
        """
        # OP_MSG is required to support encryption.
        if self.__database.client._encrypter:
            raise InvalidOperation("find_raw_batches does not support auto encryption")
        return RawBatchCursor(self, *args, **kwargs)

    def _count_cmd(
        self,
        session: Optional[ClientSession],
        conn: Connection,
        read_preference: Optional[_ServerMode],
        cmd: dict[str, Any],
        collation: Optional[Collation],
    ) -> int:
        """Internal count command helper."""
        # XXX: "ns missing" checks can be removed when we drop support for
        # MongoDB 3.0, see SERVER-17051.
        res = self._command(
            conn,
            cmd,
            read_preference=read_preference,
            allowable_errors=["ns missing"],
            codec_options=self.__write_response_codec_options,
            read_concern=self.read_concern,
            collation=collation,
            session=session,
        )
        if res.get("errmsg", "") == "ns missing":
            return 0
        return int(res["n"])

    def _aggregate_one_result(
        self,
        conn: Connection,
        read_preference: Optional[_ServerMode],
        cmd: dict[str, Any],
        collation: Optional[_CollationIn],
        session: Optional[ClientSession],
    ) -> Optional[Mapping[str, Any]]:
        """Internal helper to run an aggregate that returns a single result."""
        result = self._command(
            conn,
            cmd,
            read_preference,
            allowable_errors=[26],  # Ignore NamespaceNotFound.
            codec_options=self.__write_response_codec_options,
            read_concern=self.read_concern,
            collation=collation,
            session=session,
        )
        # cursor will not be present for NamespaceNotFound errors.
        if "cursor" not in result:
            return None
        batch = result["cursor"]["firstBatch"]
        return batch[0] if batch else None

    def estimated_document_count(self, comment: Optional[Any] = None, **kwargs: Any) -> int:
>>>>>>> origin/master
        """Get an estimate of the number of documents in this collection using
        collection metadata.

        The :meth:`estimated_document_count` method is **not** supported in a
        transaction.

        All optional parameters should be passed as keyword arguments
        to this method. Valid options include:

          - `maxTimeMS` (int): The maximum amount of time to allow this
            operation to run, in milliseconds.

<<<<<<< HEAD
        :Parameters:
          - `**kwargs` (optional): See list of options above.

        .. versionadded:: 3.7
        """
        if 'session' in kwargs:
            raise ConfigurationError(
                'estimated_document_count does not support sessions')
        cmd = SON([('count', self.__name)])
        cmd.update(kwargs)
        return self._count(cmd)

    def count_documents(self, filter, session=None, **kwargs):
=======
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: See list of options above.

        .. versionchanged:: 4.2
           This method now always uses the `count`_ command. Due to an oversight in versions
           5.0.0-5.0.8 of MongoDB, the count command was not included in V1 of the
           :ref:`versioned-api-ref`. Users of the Stable API with estimated_document_count are
           recommended to upgrade their server version to 5.0.9+ or set
           :attr:`pymongo.server_api.ServerApi.strict` to ``False`` to avoid encountering errors.

        .. versionadded:: 3.7
        .. _count: https://mongodb.com/docs/manual/reference/command/count/
        """
        if "session" in kwargs:
            raise ConfigurationError("estimated_document_count does not support sessions")
        if comment is not None:
            kwargs["comment"] = comment

        def _cmd(
            session: Optional[ClientSession],
            _server: Server,
            conn: Connection,
            read_preference: Optional[_ServerMode],
        ) -> int:
            cmd: dict[str, Any] = {"count": self.__name}
            cmd.update(kwargs)
            return self._count_cmd(session, conn, read_preference, cmd, collation=None)

        return self._retryable_non_cursor_read(_cmd, None, operation=_Op.COUNT)

    def count_documents(
        self,
        filter: Mapping[str, Any],
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> int:
>>>>>>> origin/master
        """Count the number of documents in this collection.

        .. note:: For a fast count of the total documents in a collection see
           :meth:`estimated_document_count`.

        The :meth:`count_documents` method is supported in a transaction.

        All optional parameters should be passed as keyword arguments
        to this method. Valid options include:

          - `skip` (int): The number of matching documents to skip before
            returning results.
          - `limit` (int): The maximum number of documents to count. Must be
            a positive integer. If not provided, no limit is imposed.
          - `maxTimeMS` (int): The maximum amount of time to allow this
            operation to run, in milliseconds.
          - `collation` (optional): An instance of
<<<<<<< HEAD
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `hint` (string or list of tuples): The index to use. Specify either
            the index name as a string or the index specification as a list of
            tuples (e.g. [('a', pymongo.ASCENDING), ('b', pymongo.ASCENDING)]).
            This option is only supported on MongoDB 3.6 and above.
=======
            :class:`~pymongo.collation.Collation`.
          - `hint` (string or list of tuples): The index to use. Specify either
            the index name as a string or the index specification as a list of
            tuples (e.g. [('a', pymongo.ASCENDING), ('b', pymongo.ASCENDING)]).
>>>>>>> origin/master

        The :meth:`count_documents` method obeys the :attr:`read_preference` of
        this :class:`Collection`.

        .. note:: When migrating from :meth:`count` to :meth:`count_documents`
           the following query operators must be replaced:

           +-------------+-------------------------------------+
           | Operator    | Replacement                         |
           +=============+=====================================+
           | $where      | `$expr`_                            |
           +-------------+-------------------------------------+
           | $near       | `$geoWithin`_ with `$center`_       |
           +-------------+-------------------------------------+
           | $nearSphere | `$geoWithin`_ with `$centerSphere`_ |
           +-------------+-------------------------------------+

<<<<<<< HEAD
           $expr requires MongoDB 3.6+

        :Parameters:
          - `filter` (required): A query document that selects which documents
            to count in the collection. Can be an empty document to count all
            documents.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): See list of options above.

        .. versionadded:: 3.7

        .. _$expr: https://docs.mongodb.com/manual/reference/operator/query/expr/
        .. _$geoWithin: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/
        .. _$center: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center
        .. _$centerSphere: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere
        """
        pipeline = [{'$match': filter}]
        if 'skip' in kwargs:
            pipeline.append({'$skip': kwargs.pop('skip')})
        if 'limit' in kwargs:
            pipeline.append({'$limit': kwargs.pop('limit')})
        pipeline.append({'$group': {'_id': 1, 'n': {'$sum': 1}}})
        cmd = SON([('aggregate', self.__name),
                   ('pipeline', pipeline),
                   ('cursor', {})])
        if "hint" in kwargs and not isinstance(kwargs["hint"], string_type):
            kwargs["hint"] = helpers._index_document(kwargs["hint"])
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        cmd.update(kwargs)

        def _cmd(session, server, sock_info, slave_ok):
            result = self._aggregate_one_result(
                sock_info, slave_ok, cmd, collation, session)
            if not result:
                return 0
            return result['n']

        return self.__database.client._retryable_read(
            _cmd, self._read_preference_for(session), session)

    def count(self, filter=None, session=None, **kwargs):
        """**DEPRECATED** - Get the number of documents in this collection.

        The :meth:`count` method is deprecated and **not** supported in a
        transaction. Please use :meth:`count_documents` or
        :meth:`estimated_document_count` instead.

        All optional count parameters should be passed as keyword arguments
        to this method. Valid options include:

          - `skip` (int): The number of matching documents to skip before
            returning results.
          - `limit` (int): The maximum number of documents to count. A limit
            of 0 (the default) is equivalent to setting no limit.
          - `maxTimeMS` (int): The maximum amount of time to allow the count
            command to run, in milliseconds.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `hint` (string or list of tuples): The index to use. Specify either
            the index name as a string or the index specification as a list of
            tuples (e.g. [('a', pymongo.ASCENDING), ('b', pymongo.ASCENDING)]).

        The :meth:`count` method obeys the :attr:`read_preference` of
        this :class:`Collection`.

        .. note:: When migrating from :meth:`count` to :meth:`count_documents`
           the following query operators must be replaced:

           +-------------+-------------------------------------+
           | Operator    | Replacement                         |
           +=============+=====================================+
           | $where      | `$expr`_                            |
           +-------------+-------------------------------------+
           | $near       | `$geoWithin`_ with `$center`_       |
           +-------------+-------------------------------------+
           | $nearSphere | `$geoWithin`_ with `$centerSphere`_ |
           +-------------+-------------------------------------+

           $expr requires MongoDB 3.6+

        :Parameters:
          - `filter` (optional): A query document that selects which documents
            to count in the collection.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): See list of options above.

        .. versionchanged:: 3.7
           Deprecated.

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.4
           Support the `collation` option.

        .. _$expr: https://docs.mongodb.com/manual/reference/operator/query/expr/
        .. _$geoWithin: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/
        .. _$center: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center
        .. _$centerSphere: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere
        """
        warnings.warn("count is deprecated. Use estimated_document_count or "
                      "count_documents instead. Please note that $where must "
                      "be replaced by $expr, $near must be replaced by "
                      "$geoWithin with $center, and $nearSphere must be "
                      "replaced by $geoWithin with $centerSphere",
                      DeprecationWarning, stacklevel=2)
        cmd = SON([("count", self.__name)])
        if filter is not None:
            if "query" in kwargs:
                raise ConfigurationError("can't pass both filter and query")
            kwargs["query"] = filter
        if "hint" in kwargs and not isinstance(kwargs["hint"], string_type):
            kwargs["hint"] = helpers._index_document(kwargs["hint"])
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        cmd.update(kwargs)
        return self._count(cmd, collation, session)

    def create_indexes(self, indexes, session=None, **kwargs):
=======
        :param filter: A query document that selects which documents
            to count in the collection. Can be an empty document to count all
            documents.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: See list of options above.


        .. versionadded:: 3.7

        .. _$expr: https://mongodb.com/docs/manual/reference/operator/query/expr/
        .. _$geoWithin: https://mongodb.com/docs/manual/reference/operator/query/geoWithin/
        .. _$center: https://mongodb.com/docs/manual/reference/operator/query/center/
        .. _$centerSphere: https://mongodb.com/docs/manual/reference/operator/query/centerSphere/
        """
        pipeline = [{"$match": filter}]
        if "skip" in kwargs:
            pipeline.append({"$skip": kwargs.pop("skip")})
        if "limit" in kwargs:
            pipeline.append({"$limit": kwargs.pop("limit")})
        if comment is not None:
            kwargs["comment"] = comment
        pipeline.append({"$group": {"_id": 1, "n": {"$sum": 1}}})
        cmd = {"aggregate": self.__name, "pipeline": pipeline, "cursor": {}}
        if "hint" in kwargs and not isinstance(kwargs["hint"], str):
            kwargs["hint"] = helpers._index_document(kwargs["hint"])
        collation = validate_collation_or_none(kwargs.pop("collation", None))
        cmd.update(kwargs)

        def _cmd(
            session: Optional[ClientSession],
            _server: Server,
            conn: Connection,
            read_preference: Optional[_ServerMode],
        ) -> int:
            result = self._aggregate_one_result(conn, read_preference, cmd, collation, session)
            if not result:
                return 0
            return result["n"]

        return self._retryable_non_cursor_read(_cmd, session, _Op.COUNT)

    def _retryable_non_cursor_read(
        self,
        func: Callable[[Optional[ClientSession], Server, Connection, Optional[_ServerMode]], T],
        session: Optional[ClientSession],
        operation: str,
    ) -> T:
        """Non-cursor read helper to handle implicit session creation."""
        client = self.__database.client
        with client._tmp_session(session) as s:
            return client._retryable_read(func, self._read_preference_for(s), s, operation)

    def create_indexes(
        self,
        indexes: Sequence[IndexModel],
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> list[str]:
>>>>>>> origin/master
        """Create one or more indexes on this collection.

          >>> from pymongo import IndexModel, ASCENDING, DESCENDING
          >>> index1 = IndexModel([("hello", DESCENDING),
          ...                      ("world", ASCENDING)], name="hello_world")
          >>> index2 = IndexModel([("goodbye", DESCENDING)])
          >>> db.test.create_indexes([index1, index2])
          ["hello_world", "goodbye_-1"]

<<<<<<< HEAD
        :Parameters:
          - `indexes`: A list of :class:`~pymongo.operations.IndexModel`
            instances.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        .. note:: `create_indexes` uses the `createIndexes`_ command
           introduced in MongoDB **2.6** and cannot be used with earlier
           versions.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation when using
           MongoDB >= 3.4.
=======
        :param indexes: A list of :class:`~pymongo.operations.IndexModel`
            instances.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.




        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter. Added support for arbitrary keyword
           arguments.

        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4.
        .. versionadded:: 3.0

<<<<<<< HEAD
        .. _createIndexes: https://docs.mongodb.com/manual/reference/command/createIndexes/
        """
        common.validate_list('indexes', indexes)
        return self.__create_indexes(indexes, session, **kwargs)

    def __create_indexes(self, indexes, session, **kwargs):
        """Internal createIndexes helper.

        :Parameters:
          - `indexes`: A list of :class:`~pymongo.operations.IndexModel`
            instances.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.
        """
        names = []
        with self._socket_for_writes(session) as sock_info:
            supports_collations = sock_info.max_wire_version >= 5
            supports_quorum = sock_info.max_wire_version >= 9

            def gen_indexes():
                for index in indexes:
                    if not isinstance(index, IndexModel):
                        raise TypeError(
                            "%r is not an instance of "
                            "pymongo.operations.IndexModel" % (index,))
                    document = index.document
                    if "collation" in document and not supports_collations:
                        raise ConfigurationError(
                            "Must be connected to MongoDB "
                            "3.4+ to use collations.")
                    if 'bucketSize' in document:
                        # The bucketSize option is required by geoHaystack.
                        warnings.warn(
                            _HAYSTACK_MSG, DeprecationWarning, stacklevel=4)
                    names.append(document["name"])
                    yield document

            cmd = SON([('createIndexes', self.name),
                       ('indexes', list(gen_indexes()))])
            cmd.update(kwargs)
            if 'commitQuorum' in kwargs and not supports_quorum:
                raise ConfigurationError(
                    "Must be connected to MongoDB 4.4+ to use the "
                    "commitQuorum option for createIndexes")

            self._command(
                sock_info, cmd, read_preference=ReadPreference.PRIMARY,
                codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
                write_concern=self._write_concern_for(session),
                session=session)
        return names

    def create_index(self, keys, session=None, **kwargs):
        """Creates an index on this collection.

        Takes either a single key or a list of (key, direction) pairs.
        The key(s) must be an instance of :class:`basestring`
        (:class:`str` in python 3), and the direction(s) must be one of
        (:data:`~pymongo.ASCENDING`, :data:`~pymongo.DESCENDING`,
        :data:`~pymongo.GEO2D`, :data:`~pymongo.GEOHAYSTACK`,
        :data:`~pymongo.GEOSPHERE`, :data:`~pymongo.HASHED`,
        :data:`~pymongo.TEXT`).
=======
        .. _createIndexes: https://mongodb.com/docs/manual/reference/command/createIndexes/
        """
        common.validate_list("indexes", indexes)
        if comment is not None:
            kwargs["comment"] = comment
        return self.__create_indexes(indexes, session, **kwargs)

    @_csot.apply
    def __create_indexes(
        self, indexes: Sequence[IndexModel], session: Optional[ClientSession], **kwargs: Any
    ) -> list[str]:
        """Internal createIndexes helper.

        :param indexes: A list of :class:`~pymongo.operations.IndexModel`
            instances.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param kwargs: optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.
        """
        names = []
        with self._conn_for_writes(session, operation=_Op.CREATE_INDEXES) as conn:
            supports_quorum = conn.max_wire_version >= 9

            def gen_indexes() -> Iterator[Mapping[str, Any]]:
                for index in indexes:
                    if not isinstance(index, IndexModel):
                        raise TypeError(
                            f"{index!r} is not an instance of pymongo.operations.IndexModel"
                        )
                    document = index.document
                    names.append(document["name"])
                    yield document

            cmd = {"createIndexes": self.name, "indexes": list(gen_indexes())}
            cmd.update(kwargs)
            if "commitQuorum" in kwargs and not supports_quorum:
                raise ConfigurationError(
                    "Must be connected to MongoDB 4.4+ to use the "
                    "commitQuorum option for createIndexes"
                )

            self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
                write_concern=self._write_concern_for(session),
                session=session,
            )
        return names

    def create_index(
        self,
        keys: _IndexKeyHint,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> str:
        """Creates an index on this collection.

        Takes either a single key or a list containing (key, direction) pairs
        or keys.  If no direction is given, :data:`~pymongo.ASCENDING` will
        be assumed.
        The key(s) must be an instance of :class:`str` and the direction(s) must
        be one of (:data:`~pymongo.ASCENDING`, :data:`~pymongo.DESCENDING`,
        :data:`~pymongo.GEO2D`, :data:`~pymongo.GEOSPHERE`,
        :data:`~pymongo.HASHED`, :data:`~pymongo.TEXT`).
>>>>>>> origin/master

        To create a single key ascending index on the key ``'mike'`` we just
        use a string argument::

          >>> my_collection.create_index("mike")

        For a compound index on ``'mike'`` descending and ``'eliot'``
        ascending we need to use a list of tuples::

          >>> my_collection.create_index([("mike", pymongo.DESCENDING),
<<<<<<< HEAD
          ...                             ("eliot", pymongo.ASCENDING)])
=======
          ...                             "eliot"])
>>>>>>> origin/master

        All optional index creation parameters should be passed as
        keyword arguments to this method. For example::

          >>> my_collection.create_index([("mike", pymongo.DESCENDING)],
          ...                            background=True)

        Valid options include, but are not limited to:

          - `name`: custom name to use for this index - if none is
            given, a name will be generated.
          - `unique`: if ``True``, creates a uniqueness constraint on the
            index.
          - `background`: if ``True``, this index should be created in the
            background.
          - `sparse`: if ``True``, omit from the index any documents that lack
            the indexed field.
          - `bucketSize`: for use with geoHaystack indexes.
            Number of documents to group together within a certain proximity
            to a given longitude and latitude.
          - `min`: minimum value for keys in a :data:`~pymongo.GEO2D`
            index.
          - `max`: maximum value for keys in a :data:`~pymongo.GEO2D`
            index.
          - `expireAfterSeconds`: <int> Used to create an expiring (TTL)
            collection. MongoDB will automatically delete documents from
            this collection after <int> seconds. The indexed field must
            be a UTC datetime or the data will not expire.
          - `partialFilterExpression`: A document that specifies a filter for
<<<<<<< HEAD
            a partial index. Requires MongoDB >=3.2.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. Requires MongoDB >= 3.4.
=======
            a partial index.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`.
>>>>>>> origin/master
          - `wildcardProjection`: Allows users to include or exclude specific
            field paths from a `wildcard index`_ using the {"$**" : 1} key
            pattern. Requires MongoDB >= 4.2.
          - `hidden`: if ``True``, this index will be hidden from the query
            planner and will not be evaluated as part of query plan
            selection. Requires MongoDB >= 4.4.

        See the MongoDB documentation for a full list of supported options by
        server version.

        .. warning:: `dropDups` is not supported by MongoDB 3.0 or newer. The
          option is silently ignored by the server and unique index builds
          using the option will fail if a duplicate value is detected.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
<<<<<<< HEAD
           this collection is automatically applied to this operation when using
           MongoDB >= 3.4.

        :Parameters:
          - `keys`: a single key or a list of (key, direction)
            pairs specifying the index to create
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): any additional index creation
            options (see the above list) should be passed as keyword
            arguments

=======
           this collection is automatically applied to this operation.

        :param keys: a single key or a list of (key, direction)
            pairs specifying the index to create
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: any additional index creation
            options (see the above list) should be passed as keyword
            arguments.

        .. versionchanged:: 4.4
           Allow passing a list containing (key, direction) pairs
           or keys for the ``keys`` parameter.
        .. versionchanged:: 4.1
           Added ``comment`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added the ``hidden`` option.
        .. versionchanged:: 3.6
           Added ``session`` parameter. Added support for passing maxTimeMS
           in kwargs.
        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4. Support the `collation` option.
        .. versionchanged:: 3.2
           Added partialFilterExpression to support partial indexes.
        .. versionchanged:: 3.0
           Renamed `key_or_list` to `keys`. Removed the `cache_for` option.
           :meth:`create_index` no longer caches index names. Removed support
           for the drop_dups and bucket_size aliases.

<<<<<<< HEAD
        .. mongodoc:: indexes

        .. _wildcard index: https://docs.mongodb.com/master/core/index-wildcard/#wildcard-index-core
=======
        .. seealso:: The MongoDB documentation on `indexes <https://dochub.mongodb.org/core/indexes>`_.

        .. _wildcard index: https://dochub.mongodb.org/core/index-wildcard/
>>>>>>> origin/master
        """
        cmd_options = {}
        if "maxTimeMS" in kwargs:
            cmd_options["maxTimeMS"] = kwargs.pop("maxTimeMS")
<<<<<<< HEAD
        index = IndexModel(keys, **kwargs)
        return self.__create_indexes([index], session, **cmd_options)[0]

    def ensure_index(self, key_or_list, cache_for=300, **kwargs):
        """**DEPRECATED** - Ensures that an index exists on this collection.

        .. versionchanged:: 3.0
            **DEPRECATED**
        """
        warnings.warn("ensure_index is deprecated. Use create_index instead.",
                      DeprecationWarning, stacklevel=2)
        # The types supported by datetime.timedelta.
        if not (isinstance(cache_for, integer_types) or
                isinstance(cache_for, float)):
            raise TypeError("cache_for must be an integer or float.")

        if "drop_dups" in kwargs:
            kwargs["dropDups"] = kwargs.pop("drop_dups")

        if "bucket_size" in kwargs:
            kwargs["bucketSize"] = kwargs.pop("bucket_size")

        index = IndexModel(key_or_list, **kwargs)
        name = index.document["name"]

        # Note that there is a race condition here. One thread could
        # check if the index is cached and be preempted before creating
        # and caching the index. This means multiple threads attempting
        # to create the same index concurrently could send the index
        # to the server two or more times. This has no practical impact
        # other than wasted round trips.
        if not self.__database.client._cached(self.__database.name,
                                              self.__name, name):
            self.__create_indexes([index], session=None)
            self.__database.client._cache_index(self.__database.name,
                                                self.__name, name, cache_for)
            return name
        return None

    def drop_indexes(self, session=None, **kwargs):
        """Drops all indexes on this collection.

        Can be used on non-existant collections or collections with no indexes.
        Raises OperationFailure on an error.

        :Parameters:
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation when using
           MongoDB >= 3.4.
=======
        if comment is not None:
            cmd_options["comment"] = comment
        index = IndexModel(keys, **kwargs)
        return self.__create_indexes([index], session, **cmd_options)[0]

    def drop_indexes(
        self,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> None:
        """Drops all indexes on this collection.

        Can be used on non-existent collections or collections with no indexes.
        Raises OperationFailure on an error.

        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter. Added support for arbitrary keyword
           arguments.

        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4.
<<<<<<< HEAD

        """
        self.__database.client._purge_index(self.__database.name, self.__name)
        self.drop_index("*", session=session, **kwargs)

    def drop_index(self, index_or_name, session=None, **kwargs):
        """Drops the specified index on this collection.

        Can be used on non-existant collections or collections with no
=======
        """
        if comment is not None:
            kwargs["comment"] = comment
        self.drop_index("*", session=session, **kwargs)

    @_csot.apply
    def drop_index(
        self,
        index_or_name: _IndexKeyHint,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> None:
        """Drops the specified index on this collection.

        Can be used on non-existent collections or collections with no
>>>>>>> origin/master
        indexes.  Raises OperationFailure on an error (e.g. trying to
        drop an index that does not exist). `index_or_name`
        can be either an index name (as returned by `create_index`),
        or an index specifier (as passed to `create_index`). An index
        specifier should be a list of (key, direction) pairs. Raises
        TypeError if index is not an instance of (str, unicode, list).

        .. warning::

          if a custom name was used on index creation (by
<<<<<<< HEAD
          passing the `name` parameter to :meth:`create_index` or
          :meth:`ensure_index`) the index **must** be dropped by name.

        :Parameters:
          - `index_or_name`: index (or name of index) to drop
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation when using
           MongoDB >= 3.4.
=======
          passing the `name` parameter to :meth:`create_index`) the index
          **must** be dropped by name.

        :param index_or_name: index (or name of index) to drop
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the createIndexes
            command (like maxTimeMS) can be passed as keyword arguments.



        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation.

>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter. Added support for arbitrary keyword
           arguments.

        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4.

        """
        name = index_or_name
        if isinstance(index_or_name, list):
            name = helpers._gen_index_name(index_or_name)

<<<<<<< HEAD
        if not isinstance(name, string_type):
            raise TypeError("index_or_name must be an index name or list")

        self.__database.client._purge_index(
            self.__database.name, self.__name, name)
        cmd = SON([("dropIndexes", self.__name), ("index", name)])
        cmd.update(kwargs)
        with self._socket_for_writes(session) as sock_info:
            self._command(sock_info,
                          cmd,
                          read_preference=ReadPreference.PRIMARY,
                          allowable_errors=["ns not found", 26],
                          write_concern=self._write_concern_for(session),
                          session=session)

    def reindex(self, session=None, **kwargs):
        """Rebuilds all indexes on this collection.

        **DEPRECATED** - The :meth:`~reindex` method is deprecated and will be
        removed in PyMongo 4.0. Use :meth:`~pymongo.database.Database.command`
        to run the ``reIndex`` command directly instead::

          db.command({"reIndex": "<collection_name>"})

        .. note:: Starting in MongoDB 4.6, the `reIndex` command can only be
          run when connected to a standalone mongod.

        :Parameters:
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): optional arguments to the reIndex
            command (like maxTimeMS) can be passed as keyword arguments.

        .. warning:: reindex blocks all other operations (indexes
           are built in the foreground) and will be slow for large
           collections.

        .. versionchanged:: 3.11
           Deprecated.

        .. versionchanged:: 3.6
           Added ``session`` parameter. Added support for arbitrary keyword
           arguments.

        .. versionchanged:: 3.5
           We no longer apply this collection's write concern to this operation.
           MongoDB 3.4 silently ignored the write concern. MongoDB 3.6+ returns
           an error if we include the write concern.

        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4.
        """
        warnings.warn("The reindex method is deprecated and will be removed in "
                      "PyMongo 4.0. Use the Database.command method to run the "
                      "reIndex command instead.",
                      DeprecationWarning, stacklevel=2)
        cmd = SON([("reIndex", self.__name)])
        cmd.update(kwargs)
        with self._socket_for_writes(session) as sock_info:
            return self._command(
                sock_info, cmd, read_preference=ReadPreference.PRIMARY,
                session=session)

    def list_indexes(self, session=None):
=======
        if not isinstance(name, str):
            raise TypeError("index_or_name must be an instance of str or list")

        cmd = {"dropIndexes": self.__name, "index": name}
        cmd.update(kwargs)
        if comment is not None:
            cmd["comment"] = comment
        with self._conn_for_writes(session, operation=_Op.DROP_INDEXES) as conn:
            self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                allowable_errors=["ns not found", 26],
                write_concern=self._write_concern_for(session),
                session=session,
            )

    def list_indexes(
        self,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
    ) -> CommandCursor[MutableMapping[str, Any]]:
>>>>>>> origin/master
        """Get a cursor over the index documents for this collection.

          >>> for index in db.test.list_indexes():
          ...     print(index)
          ...
          SON([('v', 2), ('key', SON([('_id', 1)])), ('name', '_id_')])

<<<<<<< HEAD
        :Parameters:
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.

        :Returns:
          An instance of :class:`~pymongo.command_cursor.CommandCursor`.
=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.

        :return: An instance of :class:`~pymongo.command_cursor.CommandCursor`.

        .. versionchanged:: 4.1
           Added ``comment`` parameter.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionadded:: 3.0
        """
<<<<<<< HEAD
        codec_options = CodecOptions(SON)
        coll = self.with_options(codec_options=codec_options,
                                 read_preference=ReadPreference.PRIMARY)
        read_pref = ((session and session._txn_read_preference())
                     or ReadPreference.PRIMARY)

        def _cmd(session, server, sock_info, slave_ok):
            cmd = SON([("listIndexes", self.__name), ("cursor", {})])
            if sock_info.max_wire_version > 2:
                with self.__database.client._tmp_session(session, False) as s:
                    try:
                        cursor = self._command(sock_info, cmd, slave_ok,
                                               read_pref,
                                               codec_options,
                                               session=s)["cursor"]
                    except OperationFailure as exc:
                        # Ignore NamespaceNotFound errors to match the behavior
                        # of reading from *.system.indexes.
                        if exc.code != 26:
                            raise
                        cursor = {'id': 0, 'firstBatch': []}
                return CommandCursor(coll, cursor, sock_info.address,
                                     session=s,
                                     explicit_session=session is not None)
            else:
                res = message._first_batch(
                    sock_info, self.__database.name, "system.indexes",
                    {"ns": self.__full_name}, 0, slave_ok, codec_options,
                    read_pref, cmd,
                    self.database.client._event_listeners)
                cursor = res["cursor"]
                # Note that a collection can only have 64 indexes, so there
                # will never be a getMore call.
                return CommandCursor(coll, cursor, sock_info.address)

        return self.__database.client._retryable_read(
            _cmd, read_pref, session)

    def index_information(self, session=None):
=======
        codec_options: CodecOptions = CodecOptions(SON)
        coll = cast(
            Collection[MutableMapping[str, Any]],
            self.with_options(codec_options=codec_options, read_preference=ReadPreference.PRIMARY),
        )
        read_pref = (session and session._txn_read_preference()) or ReadPreference.PRIMARY
        explicit_session = session is not None

        def _cmd(
            session: Optional[ClientSession],
            _server: Server,
            conn: Connection,
            read_preference: _ServerMode,
        ) -> CommandCursor[MutableMapping[str, Any]]:
            cmd = {"listIndexes": self.__name, "cursor": {}}
            if comment is not None:
                cmd["comment"] = comment

            try:
                cursor = self._command(conn, cmd, read_preference, codec_options, session=session)[
                    "cursor"
                ]
            except OperationFailure as exc:
                # Ignore NamespaceNotFound errors to match the behavior
                # of reading from *.system.indexes.
                if exc.code != 26:
                    raise
                cursor = {"id": 0, "firstBatch": []}
            cmd_cursor = CommandCursor(
                coll,
                cursor,
                conn.address,
                session=session,
                explicit_session=explicit_session,
                comment=cmd.get("comment"),
            )
            cmd_cursor._maybe_pin_connection(conn)
            return cmd_cursor

        with self.__database.client._tmp_session(session, False) as s:
            return self.__database.client._retryable_read(
                _cmd, read_pref, s, operation=_Op.LIST_INDEXES
            )

    def index_information(
        self,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
    ) -> MutableMapping[str, Any]:
>>>>>>> origin/master
        """Get information on this collection's indexes.

        Returns a dictionary where the keys are index names (as
        returned by create_index()) and the values are dictionaries
        containing information about each index. The dictionary is
        guaranteed to contain at least a single key, ``"key"`` which
        is a list of (key, direction) pairs specifying the index (as
        passed to create_index()). It will also contain any other
        metadata about the indexes, except for the ``"ns"`` and
        ``"name"`` keys, which are cleaned. Example output might look
        like this:

        >>> db.test.create_index("x", unique=True)
<<<<<<< HEAD
        u'x_1'
        >>> db.test.index_information()
        {u'_id_': {u'key': [(u'_id', 1)]},
         u'x_1': {u'unique': True, u'key': [(u'x', 1)]}}

        :Parameters:
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
=======
        'x_1'
        >>> db.test.index_information()
        {'_id_': {'key': [('_id', 1)]},
         'x_1': {'unique': True, 'key': [('x', 1)]}}

        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.

        .. versionchanged:: 4.1
           Added ``comment`` parameter.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter.
        """
<<<<<<< HEAD
        cursor = self.list_indexes(session=session)
        info = {}
        for index in cursor:
            index["key"] = index["key"].items()
            index = dict(index)
            info[index.pop("name")] = index
        return info

    def options(self, session=None):
=======
        cursor = self.list_indexes(session=session, comment=comment)
        info = {}
        for index in cursor:
            index["key"] = list(index["key"].items())
            index = dict(index)  # noqa: PLW2901
            info[index.pop("name")] = index
        return info

    def list_search_indexes(
        self,
        name: Optional[str] = None,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> CommandCursor[Mapping[str, Any]]:
        """Return a cursor over search indexes for the current collection.

        :param name: If given, the name of the index to search
            for.  Only indexes with matching index names will be returned.
            If not given, all search indexes for the current collection
            will be returned.
        :param session: a :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.

        :return: A :class:`~pymongo.command_cursor.CommandCursor` over the result
          set.

        .. note:: requires a MongoDB server version 7.0+ Atlas cluster.

        .. versionadded:: 4.5
        """
        if name is None:
            pipeline: _Pipeline = [{"$listSearchIndexes": {}}]
        else:
            pipeline = [{"$listSearchIndexes": {"name": name}}]

        coll = self.with_options(
            codec_options=DEFAULT_CODEC_OPTIONS,
            read_preference=ReadPreference.PRIMARY,
            write_concern=DEFAULT_WRITE_CONCERN,
            read_concern=DEFAULT_READ_CONCERN,
        )
        cmd = _CollectionAggregationCommand(
            coll,
            CommandCursor,
            pipeline,
            kwargs,
            explicit_session=session is not None,
            comment=comment,
            user_fields={"cursor": {"firstBatch": 1}},
        )

        return self.__database.client._retryable_read(
            cmd.get_cursor,
            cmd.get_read_preference(session),  # type: ignore[arg-type]
            session,
            retryable=not cmd._performs_write,
            operation=_Op.LIST_SEARCH_INDEX,
        )

    def create_search_index(
        self,
        model: Union[Mapping[str, Any], SearchIndexModel],
        session: Optional[ClientSession] = None,
        comment: Any = None,
        **kwargs: Any,
    ) -> str:
        """Create a single search index for the current collection.

        :param model: The model for the new search index.
            It can be given as a :class:`~pymongo.operations.SearchIndexModel`
            instance or a dictionary with a model "definition"  and optional
            "name".
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the createSearchIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        :return: The name of the new search index.

        .. note:: requires a MongoDB server version 7.0+ Atlas cluster.

        .. versionadded:: 4.5
        """
        if not isinstance(model, SearchIndexModel):
            model = SearchIndexModel(**model)
        return self.create_search_indexes([model], session, comment, **kwargs)[0]

    def create_search_indexes(
        self,
        models: list[SearchIndexModel],
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> list[str]:
        """Create multiple search indexes for the current collection.

        :param models: A list of :class:`~pymongo.operations.SearchIndexModel` instances.
        :param session: a :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the createSearchIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        :return: A list of the newly created search index names.

        .. note:: requires a MongoDB server version 7.0+ Atlas cluster.

        .. versionadded:: 4.5
        """
        if comment is not None:
            kwargs["comment"] = comment

        def gen_indexes() -> Iterator[Mapping[str, Any]]:
            for index in models:
                if not isinstance(index, SearchIndexModel):
                    raise TypeError(
                        f"{index!r} is not an instance of pymongo.operations.SearchIndexModel"
                    )
                yield index.document

        cmd = {"createSearchIndexes": self.name, "indexes": list(gen_indexes())}
        cmd.update(kwargs)

        with self._conn_for_writes(session, operation=_Op.CREATE_SEARCH_INDEXES) as conn:
            resp = self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
            )
            return [index["name"] for index in resp["indexesCreated"]]

    def drop_search_index(
        self,
        name: str,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> None:
        """Delete a search index by index name.

        :param name: The name of the search index to be deleted.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the dropSearchIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        .. note:: requires a MongoDB server version 7.0+ Atlas cluster.

        .. versionadded:: 4.5
        """
        cmd = {"dropSearchIndex": self.__name, "name": name}
        cmd.update(kwargs)
        if comment is not None:
            cmd["comment"] = comment
        with self._conn_for_writes(session, operation=_Op.DROP_SEARCH_INDEXES) as conn:
            self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                allowable_errors=["ns not found", 26],
                codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
            )

    def update_search_index(
        self,
        name: str,
        definition: Mapping[str, Any],
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> None:
        """Update a search index by replacing the existing index definition with the provided definition.

        :param name: The name of the search index to be updated.
        :param definition: The new search index definition.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: optional arguments to the updateSearchIndexes
            command (like maxTimeMS) can be passed as keyword arguments.

        .. note:: requires a MongoDB server version 7.0+ Atlas cluster.

        .. versionadded:: 4.5
        """
        cmd = {"updateSearchIndex": self.__name, "name": name, "definition": definition}
        cmd.update(kwargs)
        if comment is not None:
            cmd["comment"] = comment
        with self._conn_for_writes(session, operation=_Op.UPDATE_SEARCH_INDEX) as conn:
            self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                allowable_errors=["ns not found", 26],
                codec_options=_UNICODE_REPLACE_CODEC_OPTIONS,
            )

    def options(
        self,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
    ) -> MutableMapping[str, Any]:
>>>>>>> origin/master
        """Get the options set on this collection.

        Returns a dictionary of options and their values - see
        :meth:`~pymongo.database.Database.create_collection` for more
        information on the possible options. Returns an empty
        dictionary if the collection has not been created yet.

<<<<<<< HEAD
        :Parameters:
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter.
        """
        dbo = self.__database.client.get_database(
            self.__database.name,
            self.codec_options,
            self.read_preference,
            self.write_concern,
<<<<<<< HEAD
            self.read_concern)
        cursor = dbo.list_collections(
            session=session, filter={"name": self.__name})
=======
            self.read_concern,
        )
        cursor = dbo.list_collections(
            session=session, filter={"name": self.__name}, comment=comment
        )
>>>>>>> origin/master

        result = None
        for doc in cursor:
            result = doc
            break

        if not result:
            return {}

        options = result.get("options", {})
<<<<<<< HEAD
=======
        assert options is not None
>>>>>>> origin/master
        if "create" in options:
            del options["create"]

        return options

<<<<<<< HEAD
    def _aggregate(self, aggregation_command, pipeline, cursor_class, session,
                   explicit_session, **kwargs):
        # Remove things that are not command options.
        use_cursor = True
        if "useCursor" in kwargs:
            warnings.warn(
                "The useCursor option is deprecated "
                "and will be removed in PyMongo 4.0",
                DeprecationWarning, stacklevel=2)
            use_cursor = common.validate_boolean(
                "useCursor", kwargs.pop("useCursor", True))

        cmd = aggregation_command(
            self, cursor_class, pipeline, kwargs, explicit_session,
            user_fields={'cursor': {'firstBatch': 1}}, use_cursor=use_cursor)
        return self.__database.client._retryable_read(
            cmd.get_cursor, cmd.get_read_preference(session), session,
            retryable=not cmd._performs_write)

    def aggregate(self, pipeline, session=None, **kwargs):
        """Perform an aggregation using the aggregation framework on this
        collection.

=======
    @_csot.apply
    def _aggregate(
        self,
        aggregation_command: Type[_AggregationCommand],
        pipeline: _Pipeline,
        cursor_class: Type[CommandCursor],
        session: Optional[ClientSession],
        explicit_session: bool,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> CommandCursor[_DocumentType]:
        if comment is not None:
            kwargs["comment"] = comment
        cmd = aggregation_command(
            self,
            cursor_class,
            pipeline,
            kwargs,
            explicit_session,
            let,
            user_fields={"cursor": {"firstBatch": 1}},
        )

        return self.__database.client._retryable_read(
            cmd.get_cursor,
            cmd.get_read_preference(session),  # type: ignore[arg-type]
            session,
            retryable=not cmd._performs_write,
            operation=_Op.AGGREGATE,
        )

    def aggregate(
        self,
        pipeline: _Pipeline,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> CommandCursor[_DocumentType]:
        """Perform an aggregation using the aggregation framework on this
        collection.

        The :meth:`aggregate` method obeys the :attr:`read_preference` of this
        :class:`Collection`, except when ``$out`` or ``$merge`` are used on
        MongoDB <5.0, in which case
        :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY` is used.

        .. note:: This method does not support the 'explain' option. Please
           use `PyMongoExplain <https://pypi.org/project/pymongoexplain/>`_
           instead. An example is included in the :ref:`aggregate-examples`
           documentation.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation.

        :param pipeline: a list of aggregation pipeline stages
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: A dict of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. ``"$$var"``). This option is
            only supported on MongoDB >= 5.0.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: extra `aggregate command`_ parameters.

>>>>>>> origin/master
        All optional `aggregate command`_ parameters should be passed as
        keyword arguments to this method. Valid options include, but are not
        limited to:

          - `allowDiskUse` (bool): Enables writing to temporary files. When set
            to True, aggregation stages can write data to the _tmp subdirectory
            of the --dbpath directory. The default is False.
          - `maxTimeMS` (int): The maximum amount of time to allow the operation
            to run in milliseconds.
          - `batchSize` (int): The maximum number of documents to return per
            batch. Ignored if the connected mongod or mongos does not support
<<<<<<< HEAD
            returning aggregate results using a cursor, or `useCursor` is
            ``False``.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
          - `useCursor` (bool): Deprecated. Will be removed in PyMongo 4.0.

        The :meth:`aggregate` method obeys the :attr:`read_preference` of this
        :class:`Collection`, except when ``$out`` or ``$merge`` are used, in
        which case  :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`
        is used.

        .. note:: This method does not support the 'explain' option. Please
           use :meth:`~pymongo.database.Database.command` instead. An
           example is included in the :ref:`aggregate-examples` documentation.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation when using
           MongoDB >= 3.4.

        :Parameters:
          - `pipeline`: a list of aggregation pipeline stages
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): See list of options above.

        :Returns:
          A :class:`~pymongo.command_cursor.CommandCursor` over the result
          set.

=======
            returning aggregate results using a cursor.
          - `collation` (optional): An instance of
            :class:`~pymongo.collation.Collation`.


        :return: A :class:`~pymongo.command_cursor.CommandCursor` over the result
          set.

        .. versionchanged:: 4.1
           Added ``comment`` parameter.
           Added ``let`` parameter.
           Support $merge and $out executing on secondaries according to the
           collection's :attr:`read_preference`.
        .. versionchanged:: 4.0
           Removed the ``useCursor`` option.
>>>>>>> origin/master
        .. versionchanged:: 3.9
           Apply this collection's read concern to pipelines containing the
           `$out` stage when connected to MongoDB >= 4.2.
           Added support for the ``$merge`` pipeline stage.
           Aggregations that write always use read preference
           :attr:`~pymongo.read_preferences.ReadPreference.PRIMARY`.
        .. versionchanged:: 3.6
           Added the `session` parameter. Added the `maxAwaitTimeMS` option.
           Deprecated the `useCursor` option.
        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4. Support the `collation` option.
        .. versionchanged:: 3.0
           The :meth:`aggregate` method always returns a CommandCursor. The
           pipeline argument must be a list.
<<<<<<< HEAD
        .. versionchanged:: 2.7
           When the cursor option is used, return
           :class:`~pymongo.command_cursor.CommandCursor` instead of
           :class:`~pymongo.cursor.Cursor`.
        .. versionchanged:: 2.6
           Added cursor support.
        .. versionadded:: 2.3
=======
>>>>>>> origin/master

        .. seealso:: :doc:`/examples/aggregation`

        .. _aggregate command:
<<<<<<< HEAD
            https://docs.mongodb.com/manual/reference/command/aggregate
        """
        with self.__database.client._tmp_session(session, close=False) as s:
            return self._aggregate(_CollectionAggregationCommand,
                                   pipeline,
                                   CommandCursor,
                                   session=s,
                                   explicit_session=session is not None,
                                   **kwargs)

    def aggregate_raw_batches(self, pipeline, **kwargs):
=======
            https://mongodb.com/docs/manual/reference/command/aggregate
        """
        with self.__database.client._tmp_session(session, close=False) as s:
            return self._aggregate(
                _CollectionAggregationCommand,
                pipeline,
                CommandCursor,
                session=s,
                explicit_session=session is not None,
                let=let,
                comment=comment,
                **kwargs,
            )

    def aggregate_raw_batches(
        self,
        pipeline: _Pipeline,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> RawBatchCursor[_DocumentType]:
>>>>>>> origin/master
        """Perform an aggregation and retrieve batches of raw BSON.

        Similar to the :meth:`aggregate` method but returns a
        :class:`~pymongo.cursor.RawBatchCursor`.

        This example demonstrates how to work with raw batches, but in practice
        raw batches should be passed to an external library that can decode
        BSON into another data type, rather than used with PyMongo's
        :mod:`bson` module.

          >>> import bson
          >>> cursor = db.test.aggregate_raw_batches([
          ...     {'$project': {'x': {'$multiply': [2, '$x']}}}])
          >>> for batch in cursor:
          ...     print(bson.decode_all(batch))

<<<<<<< HEAD
        .. note:: aggregate_raw_batches does not support sessions or auto
           encryption.

        .. versionadded:: 3.6
        """
        # OP_MSG with document stream returns is required to support
        # sessions.
        if "session" in kwargs:
            raise ConfigurationError(
                "aggregate_raw_batches does not support sessions")

        # OP_MSG is required to support encryption.
        if self.__database.client._encrypter:
            raise InvalidOperation(
                "aggregate_raw_batches does not support auto encryption")

        return self._aggregate(_CollectionRawAggregationCommand,
                               pipeline,
                               RawBatchCommandCursor,
                               session=None,
                               explicit_session=False,
                               **kwargs)

    def watch(self, pipeline=None, full_document=None, resume_after=None,
              max_await_time_ms=None, batch_size=None, collation=None,
              start_at_operation_time=None, session=None, start_after=None):
=======
        .. note:: aggregate_raw_batches does not support auto encryption.

        .. versionchanged:: 3.12
           Added session support.

        .. versionadded:: 3.6
        """
        # OP_MSG is required to support encryption.
        if self.__database.client._encrypter:
            raise InvalidOperation("aggregate_raw_batches does not support auto encryption")
        if comment is not None:
            kwargs["comment"] = comment
        with self.__database.client._tmp_session(session, close=False) as s:
            return cast(
                RawBatchCursor[_DocumentType],
                self._aggregate(
                    _CollectionRawAggregationCommand,
                    pipeline,
                    RawBatchCommandCursor,
                    session=s,
                    explicit_session=session is not None,
                    **kwargs,
                ),
            )

    def watch(
        self,
        pipeline: Optional[_Pipeline] = None,
        full_document: Optional[str] = None,
        resume_after: Optional[Mapping[str, Any]] = None,
        max_await_time_ms: Optional[int] = None,
        batch_size: Optional[int] = None,
        collation: Optional[_CollationIn] = None,
        start_at_operation_time: Optional[Timestamp] = None,
        session: Optional[ClientSession] = None,
        start_after: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
        full_document_before_change: Optional[str] = None,
        show_expanded_events: Optional[bool] = None,
    ) -> CollectionChangeStream[_DocumentType]:
>>>>>>> origin/master
        """Watch changes on this collection.

        Performs an aggregation with an implicit initial ``$changeStream``
        stage and returns a
        :class:`~pymongo.change_stream.CollectionChangeStream` cursor which
        iterates over changes on this collection.

<<<<<<< HEAD
        Introduced in MongoDB 3.6.

=======
>>>>>>> origin/master
        .. code-block:: python

           with db.collection.watch() as stream:
               for change in stream:
                   print(change)

        The :class:`~pymongo.change_stream.CollectionChangeStream` iterable
        blocks until the next change document is returned or an error is
        raised. If the
        :meth:`~pymongo.change_stream.CollectionChangeStream.next` method
        encounters a network error when retrieving a batch from the server,
        it will automatically attempt to recreate the cursor such that no
        change events are missed. Any error encountered during the resume
        attempt indicates there may be an outage and will be raised.

        .. code-block:: python

            try:
<<<<<<< HEAD
                with db.collection.watch(
                        [{'$match': {'operationType': 'insert'}}]) as stream:
=======
                with db.collection.watch([{"$match": {"operationType": "insert"}}]) as stream:
>>>>>>> origin/master
                    for insert_change in stream:
                        print(insert_change)
            except pymongo.errors.PyMongoError:
                # The ChangeStream encountered an unrecoverable error or the
                # resume attempt failed to recreate the cursor.
<<<<<<< HEAD
                logging.error('...')
=======
                logging.error("...")
>>>>>>> origin/master

        For a precise description of the resume process see the
        `change streams specification`_.

        .. note:: Using this helper method is preferred to directly calling
            :meth:`~pymongo.collection.Collection.aggregate` with a
            ``$changeStream`` stage, for the purpose of supporting
            resumability.

        .. warning:: This Collection's :attr:`read_concern` must be
            ``ReadConcern("majority")`` in order to use the ``$changeStream``
            stage.

<<<<<<< HEAD
        :Parameters:
          - `pipeline` (optional): A list of aggregation pipeline stages to
            append to an initial ``$changeStream`` stage. Not all
            pipeline stages are valid after a ``$changeStream`` stage, see the
            MongoDB documentation on change streams for the supported stages.
          - `full_document` (optional): The fullDocument to pass as an option
            to the ``$changeStream`` stage. Allowed values: 'updateLookup'.
            When set to 'updateLookup', the change notification for partial
            updates will include both a delta describing the changes to the
            document, as well as a copy of the entire document that was
            changed from some time after the change occurred.
          - `resume_after` (optional): A resume token. If provided, the
            change stream will start returning changes that occur directly
            after the operation specified in the resume token. A resume token
            is the _id value of a change document.
          - `max_await_time_ms` (optional): The maximum time in milliseconds
            for the server to wait for changes before responding to a getMore
            operation.
          - `batch_size` (optional): The maximum number of documents to return
            per batch.
          - `collation` (optional): The :class:`~pymongo.collation.Collation`
            to use for the aggregation.
          - `start_at_operation_time` (optional): If provided, the resulting
            change stream will only return changes that occurred at or after
            the specified :class:`~bson.timestamp.Timestamp`. Requires
            MongoDB >= 4.0.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `start_after` (optional): The same as `resume_after` except that
            `start_after` can resume notifications after an invalidate event.
            This option and `resume_after` are mutually exclusive.

        :Returns:
          A :class:`~pymongo.change_stream.CollectionChangeStream` cursor.
=======
        :param pipeline: A list of aggregation pipeline stages to
            append to an initial ``$changeStream`` stage. Not all
            pipeline stages are valid after a ``$changeStream`` stage, see the
            MongoDB documentation on change streams for the supported stages.
        :param full_document: The fullDocument to pass as an option
            to the ``$changeStream`` stage. Allowed values: 'updateLookup',
            'whenAvailable', 'required'. When set to 'updateLookup', the
            change notification for partial updates will include both a delta
            describing the changes to the document, as well as a copy of the
            entire document that was changed from some time after the change
            occurred.
        :param full_document_before_change: Allowed values: 'whenAvailable'
            and 'required'. Change events may now result in a
            'fullDocumentBeforeChange' response field.
        :param resume_after: A resume token. If provided, the
            change stream will start returning changes that occur directly
            after the operation specified in the resume token. A resume token
            is the _id value of a change document.
        :param max_await_time_ms: The maximum time in milliseconds
            for the server to wait for changes before responding to a getMore
            operation.
        :param batch_size: The maximum number of documents to return
            per batch.
        :param collation: The :class:`~pymongo.collation.Collation`
            to use for the aggregation.
        :param start_at_operation_time: If provided, the resulting
            change stream will only return changes that occurred at or after
            the specified :class:`~bson.timestamp.Timestamp`. Requires
            MongoDB >= 4.0.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param start_after: The same as `resume_after` except that
            `start_after` can resume notifications after an invalidate event.
            This option and `resume_after` are mutually exclusive.
        :param comment: A user-provided comment to attach to this
            command.
        :param show_expanded_events: Include expanded events such as DDL events like `dropIndexes`.

        :return: A :class:`~pymongo.change_stream.CollectionChangeStream` cursor.

        .. versionchanged:: 4.3
           Added `show_expanded_events` parameter.

        .. versionchanged:: 4.2
           Added ``full_document_before_change`` parameter.

        .. versionchanged:: 4.1
           Added ``comment`` parameter.
>>>>>>> origin/master

        .. versionchanged:: 3.9
           Added the ``start_after`` parameter.

        .. versionchanged:: 3.7
           Added the ``start_at_operation_time`` parameter.

        .. versionadded:: 3.6

<<<<<<< HEAD
        .. mongodoc:: changeStreams

        .. _change streams specification:
            https://github.com/mongodb/specifications/blob/master/source/change-streams/change-streams.rst
        """
        return CollectionChangeStream(
            self, pipeline, full_document, resume_after, max_await_time_ms,
            batch_size, collation, start_at_operation_time, session,
            start_after)

    def group(self, key, condition, initial, reduce, finalize=None, **kwargs):
        """Perform a query similar to an SQL *group by* operation.

        **DEPRECATED** - The group command was deprecated in MongoDB 3.4. The
        :meth:`~group` method is deprecated and will be removed in PyMongo 4.0.
        Use :meth:`~aggregate` with the `$group` stage or :meth:`~map_reduce`
        instead.

        .. versionchanged:: 3.5
           Deprecated the group method.
        .. versionchanged:: 3.4
           Added the `collation` option.
        .. versionchanged:: 2.2
           Removed deprecated argument: command
        """
        warnings.warn("The group method is deprecated and will be removed in "
                      "PyMongo 4.0. Use the aggregate method with the $group "
                      "stage or the map_reduce method instead.",
                      DeprecationWarning, stacklevel=2)
        group = {}
        if isinstance(key, string_type):
            group["$keyf"] = Code(key)
        elif key is not None:
            group = {"key": helpers._fields_list_to_dict(key, "key")}
        group["ns"] = self.__name
        group["$reduce"] = Code(reduce)
        group["cond"] = condition
        group["initial"] = initial
        if finalize is not None:
            group["finalize"] = Code(finalize)

        cmd = SON([("group", group)])
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        cmd.update(kwargs)

        with self._socket_for_reads(session=None) as (sock_info, slave_ok):
            return self._command(sock_info, cmd, slave_ok,
                                 collation=collation,
                                 user_fields={'retval': 1})["retval"]

    def rename(self, new_name, session=None, **kwargs):
=======
        .. seealso:: The MongoDB documentation on `changeStreams <https://mongodb.com/docs/manual/changeStreams/>`_.

        .. _change streams specification:
            https://github.com/mongodb/specifications/blob/master/source/change-streams/change-streams.md
        """
        return CollectionChangeStream(
            self,
            pipeline,
            full_document,
            resume_after,
            max_await_time_ms,
            batch_size,
            collation,
            start_at_operation_time,
            session,
            start_after,
            comment,
            full_document_before_change,
            show_expanded_events,
        )

    @_csot.apply
    def rename(
        self,
        new_name: str,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> MutableMapping[str, Any]:
>>>>>>> origin/master
        """Rename this collection.

        If operating in auth mode, client must be authorized as an
        admin to perform this operation. Raises :class:`TypeError` if
<<<<<<< HEAD
        `new_name` is not an instance of :class:`basestring`
        (:class:`str` in python 3). Raises :class:`~pymongo.errors.InvalidName`
        if `new_name` is not a valid collection name.

        :Parameters:
          - `new_name`: new name for this collection
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): additional arguments to the rename command
=======
        `new_name` is not an instance of :class:`str`.
        Raises :class:`~pymongo.errors.InvalidName`
        if `new_name` is not a valid collection name.

        :param new_name: new name for this collection
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: additional arguments to the rename command
>>>>>>> origin/master
            may be passed as keyword arguments to this helper method
            (i.e. ``dropTarget=True``)

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
<<<<<<< HEAD
           this collection is automatically applied to this operation when using
           MongoDB >= 3.4.
=======
           this collection is automatically applied to this operation.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4.

        """
<<<<<<< HEAD
        if not isinstance(new_name, string_type):
            raise TypeError("new_name must be an "
                            "instance of %s" % (string_type.__name__,))
=======
        if not isinstance(new_name, str):
            raise TypeError("new_name must be an instance of str")
>>>>>>> origin/master

        if not new_name or ".." in new_name:
            raise InvalidName("collection names cannot be empty")
        if new_name[0] == "." or new_name[-1] == ".":
<<<<<<< HEAD
            raise InvalidName("collecion names must not start or end with '.'")
        if "$" in new_name and not new_name.startswith("oplog.$main"):
            raise InvalidName("collection names must not contain '$'")

        new_name = "%s.%s" % (self.__database.name, new_name)
        cmd = SON([("renameCollection", self.__full_name), ("to", new_name)])
        cmd.update(kwargs)
        write_concern = self._write_concern_for_cmd(cmd, session)

        with self._socket_for_writes(session) as sock_info:
            with self.__database.client._tmp_session(session) as s:
                return sock_info.command(
                    'admin', cmd,
                    write_concern=write_concern,
                    parse_write_concern_error=True,
                    session=s, client=self.__database.client)

    def distinct(self, key, filter=None, session=None, **kwargs):
=======
            raise InvalidName("collection names must not start or end with '.'")
        if "$" in new_name and not new_name.startswith("oplog.$main"):
            raise InvalidName("collection names must not contain '$'")

        new_name = f"{self.__database.name}.{new_name}"
        cmd = {"renameCollection": self.__full_name, "to": new_name}
        cmd.update(kwargs)
        if comment is not None:
            cmd["comment"] = comment
        write_concern = self._write_concern_for_cmd(cmd, session)

        with self._conn_for_writes(session, operation=_Op.RENAME) as conn:
            with self.__database.client._tmp_session(session) as s:
                return conn.command(
                    "admin",
                    cmd,
                    write_concern=write_concern,
                    parse_write_concern_error=True,
                    session=s,
                    client=self.__database.client,
                )

    def distinct(
        self,
        key: str,
        filter: Optional[Mapping[str, Any]] = None,
        session: Optional[ClientSession] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> list:
>>>>>>> origin/master
        """Get a list of distinct values for `key` among all documents
        in this collection.

        Raises :class:`TypeError` if `key` is not an instance of
<<<<<<< HEAD
        :class:`basestring` (:class:`str` in python 3).
=======
        :class:`str`.
>>>>>>> origin/master

        All optional distinct parameters should be passed as keyword arguments
        to this method. Valid options include:

          - `maxTimeMS` (int): The maximum amount of time to allow the count
            command to run, in milliseconds.
          - `collation` (optional): An instance of
<<<<<<< HEAD
            :class:`~pymongo.collation.Collation`. This option is only supported
            on MongoDB 3.4 and above.
=======
            :class:`~pymongo.collation.Collation`.
>>>>>>> origin/master

        The :meth:`distinct` method obeys the :attr:`read_preference` of
        this :class:`Collection`.

<<<<<<< HEAD
        :Parameters:
          - `key`: name of the field for which we want to get the distinct
            values
          - `filter` (optional): A query document that specifies the documents
            from which to retrieve the distinct values.
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): See list of options above.
=======
        :param key: name of the field for which we want to get the distinct
            values
        :param filter: A query document that specifies the documents
            from which to retrieve the distinct values.
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: See list of options above.
>>>>>>> origin/master

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.4
           Support the `collation` option.

        """
<<<<<<< HEAD
        if not isinstance(key, string_type):
            raise TypeError("key must be an "
                            "instance of %s" % (string_type.__name__,))
        cmd = SON([("distinct", self.__name),
                   ("key", key)])
=======
        if not isinstance(key, str):
            raise TypeError("key must be an instance of str")
        cmd = {"distinct": self.__name, "key": key}
>>>>>>> origin/master
        if filter is not None:
            if "query" in kwargs:
                raise ConfigurationError("can't pass both filter and query")
            kwargs["query"] = filter
<<<<<<< HEAD
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        cmd.update(kwargs)
        def _cmd(session, server, sock_info, slave_ok):
            return self._command(
                sock_info, cmd, slave_ok, read_concern=self.read_concern,
                collation=collation, session=session,
                user_fields={"values": 1})["values"]

        return self.__database.client._retryable_read(
            _cmd, self._read_preference_for(session), session)

    def _map_reduce(self, map, reduce, out, session, read_pref, **kwargs):
        """Internal mapReduce helper."""
        cmd = SON([("mapReduce", self.__name),
                   ("map", map),
                   ("reduce", reduce),
                   ("out", out)])
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        cmd.update(kwargs)

        inline = 'inline' in out

        if inline:
            user_fields = {'results': 1}
        else:
            user_fields = None

        read_pref = ((session and session._txn_read_preference())
                     or read_pref)

        with self.__database.client._socket_for_reads(read_pref, session) as (
                sock_info, slave_ok):
            if (sock_info.max_wire_version >= 4 and
                    ('readConcern' not in cmd) and
                    inline):
                read_concern = self.read_concern
            else:
                read_concern = None
            if 'writeConcern' not in cmd and not inline:
                write_concern = self._write_concern_for(session)
            else:
                write_concern = None

            return self._command(
                sock_info, cmd, slave_ok, read_pref,
                read_concern=read_concern,
                write_concern=write_concern,
                collation=collation, session=session,
                user_fields=user_fields)

    def map_reduce(self, map, reduce, out, full_response=False, session=None,
                   **kwargs):
        """Perform a map/reduce operation on this collection.

        If `full_response` is ``False`` (default) returns a
        :class:`~pymongo.collection.Collection` instance containing
        the results of the operation. Otherwise, returns the full
        response from the server to the `map reduce command`_.

        :Parameters:
          - `map`: map function (as a JavaScript string)
          - `reduce`: reduce function (as a JavaScript string)
          - `out`: output collection name or `out object` (dict). See
            the `map reduce command`_ documentation for available options.
            Note: `out` options are order sensitive. :class:`~bson.son.SON`
            can be used to specify multiple options.
            e.g. SON([('replace', <collection name>), ('db', <database name>)])
          - `full_response` (optional): if ``True``, return full response to
            this command - otherwise just return the result collection
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): additional arguments to the
            `map reduce command`_ may be passed as keyword arguments to this
            helper method, e.g.::

            >>> db.test.map_reduce(map, reduce, "myresults", limit=2)

        .. note:: The :meth:`map_reduce` method does **not** obey the
           :attr:`read_preference` of this :class:`Collection`. To run
           mapReduce on a secondary use the :meth:`inline_map_reduce` method
           instead.

        .. note:: The :attr:`~pymongo.collection.Collection.write_concern` of
           this collection is automatically applied to this operation (if the
           output is not inline) when using MongoDB >= 3.4.

        .. versionchanged:: 3.6
           Added ``session`` parameter.

        .. versionchanged:: 3.4
           Apply this collection's write concern automatically to this operation
           when connected to MongoDB >= 3.4.

        .. seealso:: :doc:`/examples/aggregation`

        .. versionchanged:: 3.4
           Added the `collation` option.
        .. versionchanged:: 2.2
           Removed deprecated arguments: merge_output and reduce_output

        .. _map reduce command: http://docs.mongodb.org/manual/reference/command/mapReduce/

        .. mongodoc:: mapreduce

        """
        if not isinstance(out, (string_type, abc.Mapping)):
            raise TypeError("'out' must be an instance of "
                            "%s or a mapping" % (string_type.__name__,))

        response = self._map_reduce(map, reduce, out, session,
                                    ReadPreference.PRIMARY, **kwargs)

        if full_response or not response.get('result'):
            return response
        elif isinstance(response['result'], dict):
            dbase = response['result']['db']
            coll = response['result']['collection']
            return self.__database.client[dbase][coll]
        else:
            return self.__database[response["result"]]

    def inline_map_reduce(self, map, reduce, full_response=False, session=None,
                          **kwargs):
        """Perform an inline map/reduce operation on this collection.

        Perform the map/reduce operation on the server in RAM. A result
        collection is not created. The result set is returned as a list
        of documents.

        If `full_response` is ``False`` (default) returns the
        result documents in a list. Otherwise, returns the full
        response from the server to the `map reduce command`_.

        The :meth:`inline_map_reduce` method obeys the :attr:`read_preference`
        of this :class:`Collection`.

        :Parameters:
          - `map`: map function (as a JavaScript string)
          - `reduce`: reduce function (as a JavaScript string)
          - `full_response` (optional): if ``True``, return full response to
            this command - otherwise just return the result collection
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): additional arguments to the
            `map reduce command`_ may be passed as keyword arguments to this
            helper method, e.g.::

            >>> db.test.inline_map_reduce(map, reduce, limit=2)

        .. versionchanged:: 3.6
           Added ``session`` parameter.
        .. versionchanged:: 3.4
           Added the `collation` option.
        """
        res = self._map_reduce(map, reduce, {"inline": 1}, session,
                               self.read_preference, **kwargs)

        if full_response:
            return res
        else:
            return res.get("results")

    def _write_concern_for_cmd(self, cmd, session):
        raw_wc = cmd.get('writeConcern')
=======
        collation = validate_collation_or_none(kwargs.pop("collation", None))
        cmd.update(kwargs)
        if comment is not None:
            cmd["comment"] = comment

        def _cmd(
            session: Optional[ClientSession],
            _server: Server,
            conn: Connection,
            read_preference: Optional[_ServerMode],
        ) -> list:
            return self._command(
                conn,
                cmd,
                read_preference=read_preference,
                read_concern=self.read_concern,
                collation=collation,
                session=session,
                user_fields={"values": 1},
            )["values"]

        return self._retryable_non_cursor_read(_cmd, session, operation=_Op.DISTINCT)

    def _write_concern_for_cmd(
        self, cmd: Mapping[str, Any], session: Optional[ClientSession]
    ) -> WriteConcern:
        raw_wc = cmd.get("writeConcern")
>>>>>>> origin/master
        if raw_wc is not None:
            return WriteConcern(**raw_wc)
        else:
            return self._write_concern_for(session)

<<<<<<< HEAD
    def __find_and_modify(self, filter, projection, sort, upsert=None,
                          return_document=ReturnDocument.BEFORE,
                          array_filters=None, hint=None, session=None,
                          **kwargs):
        """Internal findAndModify helper."""

        common.validate_is_mapping("filter", filter)
        if not isinstance(return_document, bool):
            raise ValueError("return_document must be "
                             "ReturnDocument.BEFORE or ReturnDocument.AFTER")
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        cmd = SON([("findAndModify", self.__name),
                   ("query", filter),
                   ("new", return_document)])
        cmd.update(kwargs)
        if projection is not None:
            cmd["fields"] = helpers._fields_list_to_dict(projection,
                                                         "projection")
        if sort is not None:
            cmd["sort"] = helpers._index_document(sort)
        if upsert is not None:
            common.validate_boolean("upsert", upsert)
            cmd["upsert"] = upsert
        if hint is not None:
            if not isinstance(hint, string_type):
=======
    def __find_and_modify(
        self,
        filter: Mapping[str, Any],
        projection: Optional[Union[Mapping[str, Any], Iterable[str]]],
        sort: Optional[_IndexList],
        upsert: Optional[bool] = None,
        return_document: bool = ReturnDocument.BEFORE,
        array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping] = None,
        **kwargs: Any,
    ) -> Any:
        """Internal findAndModify helper."""
        common.validate_is_mapping("filter", filter)
        if not isinstance(return_document, bool):
            raise ValueError(
                "return_document must be ReturnDocument.BEFORE or ReturnDocument.AFTER"
            )
        collation = validate_collation_or_none(kwargs.pop("collation", None))
        cmd = {"findAndModify": self.__name, "query": filter, "new": return_document}
        if let is not None:
            common.validate_is_mapping("let", let)
            cmd["let"] = let
        cmd.update(kwargs)
        if projection is not None:
            cmd["fields"] = helpers._fields_list_to_dict(projection, "projection")
        if sort is not None:
            cmd["sort"] = helpers._index_document(sort)
        if upsert is not None:
            validate_boolean("upsert", upsert)
            cmd["upsert"] = upsert
        if hint is not None:
            if not isinstance(hint, str):
>>>>>>> origin/master
                hint = helpers._index_document(hint)

        write_concern = self._write_concern_for_cmd(cmd, session)

<<<<<<< HEAD
        def _find_and_modify(session, sock_info, retryable_write):
            if array_filters is not None:
                if sock_info.max_wire_version < 6:
                    raise ConfigurationError(
                        'Must be connected to MongoDB 3.6+ to use '
                        'arrayFilters.')
                if not write_concern.acknowledged:
                    raise ConfigurationError(
                        'arrayFilters is unsupported for unacknowledged '
                        'writes.')
                cmd["arrayFilters"] = array_filters
            if hint is not None:
                if sock_info.max_wire_version < 8:
                    raise ConfigurationError(
                        'Must be connected to MongoDB 4.2+ to use hint.')
                if not write_concern.acknowledged:
                    raise ConfigurationError(
                        'hint is unsupported for unacknowledged writes.')
                cmd['hint'] = hint
            if (sock_info.max_wire_version >= 4 and
                    not write_concern.is_server_default):
                cmd['writeConcern'] = write_concern.document
            out = self._command(sock_info, cmd,
                                read_preference=ReadPreference.PRIMARY,
                                write_concern=write_concern,
                                collation=collation, session=session,
                                retryable_write=retryable_write,
                                user_fields=_FIND_AND_MODIFY_DOC_FIELDS)
=======
        def _find_and_modify(
            session: Optional[ClientSession], conn: Connection, retryable_write: bool
        ) -> Any:
            acknowledged = write_concern.acknowledged
            if array_filters is not None:
                if not acknowledged:
                    raise ConfigurationError(
                        "arrayFilters is unsupported for unacknowledged writes."
                    )
                cmd["arrayFilters"] = list(array_filters)
            if hint is not None:
                if conn.max_wire_version < 8:
                    raise ConfigurationError(
                        "Must be connected to MongoDB 4.2+ to use hint on find and modify commands."
                    )
                elif not acknowledged and conn.max_wire_version < 9:
                    raise ConfigurationError(
                        "Must be connected to MongoDB 4.4+ to use hint on unacknowledged find and modify commands."
                    )
                cmd["hint"] = hint
            out = self._command(
                conn,
                cmd,
                read_preference=ReadPreference.PRIMARY,
                write_concern=write_concern,
                collation=collation,
                session=session,
                retryable_write=retryable_write,
                user_fields=_FIND_AND_MODIFY_DOC_FIELDS,
            )
>>>>>>> origin/master
            _check_write_command_response(out)

            return out.get("value")

        return self.__database.client._retryable_write(
<<<<<<< HEAD
            write_concern.acknowledged, _find_and_modify, session)

    def find_one_and_delete(self, filter,
                            projection=None, sort=None, hint=None,
                            session=None, **kwargs):
=======
            write_concern.acknowledged,
            _find_and_modify,
            session,
            operation=_Op.FIND_AND_MODIFY,
        )

    def find_one_and_delete(
        self,
        filter: Mapping[str, Any],
        projection: Optional[Union[Mapping[str, Any], Iterable[str]]] = None,
        sort: Optional[_IndexList] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> _DocumentType:
>>>>>>> origin/master
        """Finds a single document and deletes it, returning the document.

          >>> db.test.count_documents({'x': 1})
          2
          >>> db.test.find_one_and_delete({'x': 1})
<<<<<<< HEAD
          {u'x': 1, u'_id': ObjectId('54f4e12bfba5220aa4d6dee8')}
=======
          {'x': 1, '_id': ObjectId('54f4e12bfba5220aa4d6dee8')}
>>>>>>> origin/master
          >>> db.test.count_documents({'x': 1})
          1

        If multiple documents match *filter*, a *sort* can be applied.

          >>> for doc in db.test.find({'x': 1}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': 0}
          {u'x': 1, u'_id': 1}
          {u'x': 1, u'_id': 2}
          >>> db.test.find_one_and_delete(
          ...     {'x': 1}, sort=[('_id', pymongo.DESCENDING)])
          {u'x': 1, u'_id': 2}
=======
          {'x': 1, '_id': 0}
          {'x': 1, '_id': 1}
          {'x': 1, '_id': 2}
          >>> db.test.find_one_and_delete(
          ...     {'x': 1}, sort=[('_id', pymongo.DESCENDING)])
          {'x': 1, '_id': 2}
>>>>>>> origin/master

        The *projection* option can be used to limit the fields returned.

          >>> db.test.find_one_and_delete({'x': 1}, projection={'_id': False})
<<<<<<< HEAD
          {u'x': 1}

        :Parameters:
          - `filter`: A query that matches the document to delete.
          - `projection` (optional): a list of field names that should be
=======
          {'x': 1}

        :param filter: A query that matches the document to delete.
        :param projection: a list of field names that should be
>>>>>>> origin/master
            returned in the result document or a mapping specifying the fields
            to include or exclude. If `projection` is a list "_id" will
            always be returned. Use a mapping to exclude fields from
            the result (e.g. projection={'_id': False}).
<<<<<<< HEAD
          - `sort` (optional): a list of (key, direction) pairs
            specifying the sort order for the query. If multiple documents
            match the query, they are sorted and the first is deleted.
          - `hint` (optional): An index to use to support the query predicate
=======
        :param sort: a list of (key, direction) pairs
            specifying the sort order for the query. If multiple documents
            match the query, they are sorted and the first is deleted.
        :param hint: An index to use to support the query predicate
>>>>>>> origin/master
            specified either by its string name, or in the same format as
            passed to :meth:`~pymongo.collection.Collection.create_index`
            (e.g. ``[('field', ASCENDING)]``). This option is only supported
            on MongoDB 4.4 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): additional command arguments can be passed
            as keyword arguments (for example maxTimeMS can be used with
            recent server versions).

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: additional command arguments can be passed
            as keyword arguments (for example maxTimeMS can be used with
            recent server versions).

        .. versionchanged:: 4.1
           Added ``let`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added ``hint`` parameter.
        .. versionchanged:: 3.6
           Added ``session`` parameter.
        .. versionchanged:: 3.2
           Respects write concern.

        .. warning:: Starting in PyMongo 3.2, this command uses the
           :class:`~pymongo.write_concern.WriteConcern` of this
           :class:`~pymongo.collection.Collection` when connected to MongoDB >=
           3.2. Note that using an elevated write concern with this command may
           be slower compared to using the default write concern.

        .. versionchanged:: 3.4
           Added the `collation` option.
        .. versionadded:: 3.0
        """
<<<<<<< HEAD
        kwargs['remove'] = True
        return self.__find_and_modify(filter, projection, sort,
                                      hint=hint, session=session, **kwargs)

    def find_one_and_replace(self, filter, replacement,
                             projection=None, sort=None, upsert=False,
                             return_document=ReturnDocument.BEFORE,
                             hint=None, session=None, **kwargs):
=======
        kwargs["remove"] = True
        if comment is not None:
            kwargs["comment"] = comment
        return self.__find_and_modify(
            filter, projection, sort, let=let, hint=hint, session=session, **kwargs
        )

    def find_one_and_replace(
        self,
        filter: Mapping[str, Any],
        replacement: Mapping[str, Any],
        projection: Optional[Union[Mapping[str, Any], Iterable[str]]] = None,
        sort: Optional[_IndexList] = None,
        upsert: bool = False,
        return_document: bool = ReturnDocument.BEFORE,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> _DocumentType:
>>>>>>> origin/master
        """Finds a single document and replaces it, returning either the
        original or the replaced document.

        The :meth:`find_one_and_replace` method differs from
        :meth:`find_one_and_update` by replacing the document matched by
        *filter*, rather than modifying the existing document.

          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'x': 1, u'_id': 0}
          {u'x': 1, u'_id': 1}
          {u'x': 1, u'_id': 2}
          >>> db.test.find_one_and_replace({'x': 1}, {'y': 1})
          {u'x': 1, u'_id': 0}
          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
          {u'y': 1, u'_id': 0}
          {u'x': 1, u'_id': 1}
          {u'x': 1, u'_id': 2}

        :Parameters:
          - `filter`: A query that matches the document to replace.
          - `replacement`: The replacement document.
          - `projection` (optional): A list of field names that should be
=======
          {'x': 1, '_id': 0}
          {'x': 1, '_id': 1}
          {'x': 1, '_id': 2}
          >>> db.test.find_one_and_replace({'x': 1}, {'y': 1})
          {'x': 1, '_id': 0}
          >>> for doc in db.test.find({}):
          ...     print(doc)
          ...
          {'y': 1, '_id': 0}
          {'x': 1, '_id': 1}
          {'x': 1, '_id': 2}

        :param filter: A query that matches the document to replace.
        :param replacement: The replacement document.
        :param projection: A list of field names that should be
>>>>>>> origin/master
            returned in the result document or a mapping specifying the fields
            to include or exclude. If `projection` is a list "_id" will
            always be returned. Use a mapping to exclude fields from
            the result (e.g. projection={'_id': False}).
<<<<<<< HEAD
          - `sort` (optional): a list of (key, direction) pairs
            specifying the sort order for the query. If multiple documents
            match the query, they are sorted and the first is replaced.
          - `upsert` (optional): When ``True``, inserts a new document if no
            document matches the query. Defaults to ``False``.
          - `return_document`: If
=======
        :param sort: a list of (key, direction) pairs
            specifying the sort order for the query. If multiple documents
            match the query, they are sorted and the first is replaced.
        :param upsert: When ``True``, inserts a new document if no
            document matches the query. Defaults to ``False``.
        :param return_document: If
>>>>>>> origin/master
            :attr:`ReturnDocument.BEFORE` (the default),
            returns the original document before it was replaced, or ``None``
            if no document matches. If
            :attr:`ReturnDocument.AFTER`, returns the replaced
            or inserted document.
<<<<<<< HEAD
          - `hint` (optional): An index to use to support the query
=======
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.4 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): additional command arguments can be passed
            as keyword arguments (for example maxTimeMS can be used with
            recent server versions).

=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: additional command arguments can be passed
            as keyword arguments (for example maxTimeMS can be used with
            recent server versions).

        .. versionchanged:: 4.1
           Added ``let`` parameter.
>>>>>>> origin/master
        .. versionchanged:: 3.11
           Added the ``hint`` option.
        .. versionchanged:: 3.6
           Added ``session`` parameter.
        .. versionchanged:: 3.4
           Added the ``collation`` option.
        .. versionchanged:: 3.2
           Respects write concern.

        .. warning:: Starting in PyMongo 3.2, this command uses the
           :class:`~pymongo.write_concern.WriteConcern` of this
           :class:`~pymongo.collection.Collection` when connected to MongoDB >=
           3.2. Note that using an elevated write concern with this command may
           be slower compared to using the default write concern.

        .. versionadded:: 3.0
        """
        common.validate_ok_for_replace(replacement)
<<<<<<< HEAD
        kwargs['update'] = replacement
        return self.__find_and_modify(filter, projection,
                                      sort, upsert, return_document,
                                      hint=hint, session=session, **kwargs)

    def find_one_and_update(self, filter, update,
                            projection=None, sort=None, upsert=False,
                            return_document=ReturnDocument.BEFORE,
                            array_filters=None, hint=None, session=None,
                            **kwargs):
=======
        kwargs["update"] = replacement
        if comment is not None:
            kwargs["comment"] = comment
        return self.__find_and_modify(
            filter,
            projection,
            sort,
            upsert,
            return_document,
            let=let,
            hint=hint,
            session=session,
            **kwargs,
        )

    def find_one_and_update(
        self,
        filter: Mapping[str, Any],
        update: Union[Mapping[str, Any], _Pipeline],
        projection: Optional[Union[Mapping[str, Any], Iterable[str]]] = None,
        sort: Optional[_IndexList] = None,
        upsert: bool = False,
        return_document: bool = ReturnDocument.BEFORE,
        array_filters: Optional[Sequence[Mapping[str, Any]]] = None,
        hint: Optional[_IndexKeyHint] = None,
        session: Optional[ClientSession] = None,
        let: Optional[Mapping[str, Any]] = None,
        comment: Optional[Any] = None,
        **kwargs: Any,
    ) -> _DocumentType:
>>>>>>> origin/master
        """Finds a single document and updates it, returning either the
        original or the updated document.

          >>> db.test.find_one_and_update(
          ...    {'_id': 665}, {'$inc': {'count': 1}, '$set': {'done': True}})
<<<<<<< HEAD
          {u'_id': 665, u'done': False, u'count': 25}}
=======
          {'_id': 665, 'done': False, 'count': 25}}
>>>>>>> origin/master

        Returns ``None`` if no document matches the filter.

          >>> db.test.find_one_and_update(
          ...    {'_exists': False}, {'$inc': {'count': 1}})

        When the filter matches, by default :meth:`find_one_and_update`
        returns the original version of the document before the update was
        applied. To return the updated (or inserted in the case of
        *upsert*) version of the document instead, use the *return_document*
        option.

          >>> from pymongo import ReturnDocument
          >>> db.example.find_one_and_update(
          ...     {'_id': 'userid'},
          ...     {'$inc': {'seq': 1}},
          ...     return_document=ReturnDocument.AFTER)
<<<<<<< HEAD
          {u'_id': u'userid', u'seq': 1}
=======
          {'_id': 'userid', 'seq': 1}
>>>>>>> origin/master

        You can limit the fields returned with the *projection* option.

          >>> db.example.find_one_and_update(
          ...     {'_id': 'userid'},
          ...     {'$inc': {'seq': 1}},
          ...     projection={'seq': True, '_id': False},
          ...     return_document=ReturnDocument.AFTER)
<<<<<<< HEAD
          {u'seq': 2}
=======
          {'seq': 2}
>>>>>>> origin/master

        The *upsert* option can be used to create the document if it doesn't
        already exist.

          >>> db.example.delete_many({}).deleted_count
          1
          >>> db.example.find_one_and_update(
          ...     {'_id': 'userid'},
          ...     {'$inc': {'seq': 1}},
          ...     projection={'seq': True, '_id': False},
          ...     upsert=True,
          ...     return_document=ReturnDocument.AFTER)
<<<<<<< HEAD
          {u'seq': 1}
=======
          {'seq': 1}
>>>>>>> origin/master

        If multiple documents match *filter*, a *sort* can be applied.

          >>> for doc in db.test.find({'done': True}):
          ...     print(doc)
          ...
<<<<<<< HEAD
          {u'_id': 665, u'done': True, u'result': {u'count': 26}}
          {u'_id': 701, u'done': True, u'result': {u'count': 17}}
=======
          {'_id': 665, 'done': True, 'result': {'count': 26}}
          {'_id': 701, 'done': True, 'result': {'count': 17}}
>>>>>>> origin/master
          >>> db.test.find_one_and_update(
          ...     {'done': True},
          ...     {'$set': {'final': True}},
          ...     sort=[('_id', pymongo.DESCENDING)])
<<<<<<< HEAD
          {u'_id': 701, u'done': True, u'result': {u'count': 17}}

        :Parameters:
          - `filter`: A query that matches the document to update.
          - `update`: The update operations to apply.
          - `projection` (optional): A list of field names that should be
=======
          {'_id': 701, 'done': True, 'result': {'count': 17}}

        :param filter: A query that matches the document to update.
        :param update: The update operations to apply.
        :param projection: A list of field names that should be
>>>>>>> origin/master
            returned in the result document or a mapping specifying the fields
            to include or exclude. If `projection` is a list "_id" will
            always be returned. Use a dict to exclude fields from
            the result (e.g. projection={'_id': False}).
<<<<<<< HEAD
          - `sort` (optional): a list of (key, direction) pairs
            specifying the sort order for the query. If multiple documents
            match the query, they are sorted and the first is updated.
          - `upsert` (optional): When ``True``, inserts a new document if no
            document matches the query. Defaults to ``False``.
          - `return_document`: If
=======
        :param sort: a list of (key, direction) pairs
            specifying the sort order for the query. If multiple documents
            match the query, they are sorted and the first is updated.
        :param upsert: When ``True``, inserts a new document if no
            document matches the query. Defaults to ``False``.
        :param return_document: If
>>>>>>> origin/master
            :attr:`ReturnDocument.BEFORE` (the default),
            returns the original document before it was updated. If
            :attr:`ReturnDocument.AFTER`, returns the updated
            or inserted document.
<<<<<<< HEAD
          - `array_filters` (optional): A list of filters specifying which
            array elements an update should apply. This option is only
            supported on MongoDB 3.6 and above.
          - `hint` (optional): An index to use to support the query
=======
        :param array_filters: A list of filters specifying which
            array elements an update should apply.
        :param hint: An index to use to support the query
>>>>>>> origin/master
            predicate specified either by its string name, or in the same
            format as passed to
            :meth:`~pymongo.collection.Collection.create_index` (e.g.
            ``[('field', ASCENDING)]``). This option is only supported on
            MongoDB 4.4 and above.
<<<<<<< HEAD
          - `session` (optional): a
            :class:`~pymongo.client_session.ClientSession`.
          - `**kwargs` (optional): additional command arguments can be passed
=======
        :param session: a
            :class:`~pymongo.client_session.ClientSession`.
        :param let: Map of parameter names and values. Values must be
            constant or closed expressions that do not reference document
            fields. Parameters can then be accessed as variables in an
            aggregate expression context (e.g. "$$var").
        :param comment: A user-provided comment to attach to this
            command.
        :param kwargs: additional command arguments can be passed
>>>>>>> origin/master
            as keyword arguments (for example maxTimeMS can be used with
            recent server versions).

        .. versionchanged:: 3.11
           Added the ``hint`` option.
        .. versionchanged:: 3.9
           Added the ability to accept a pipeline as the ``update``.
        .. versionchanged:: 3.6
           Added the ``array_filters`` and ``session`` options.
        .. versionchanged:: 3.4
           Added the ``collation`` option.
        .. versionchanged:: 3.2
           Respects write concern.

        .. warning:: Starting in PyMongo 3.2, this command uses the
           :class:`~pymongo.write_concern.WriteConcern` of this
           :class:`~pymongo.collection.Collection` when connected to MongoDB >=
           3.2. Note that using an elevated write concern with this command may
           be slower compared to using the default write concern.

        .. versionadded:: 3.0
        """
        common.validate_ok_for_update(update)
<<<<<<< HEAD
        common.validate_list_or_none('array_filters', array_filters)
        kwargs['update'] = update
        return self.__find_and_modify(filter, projection,
                                      sort, upsert, return_document,
                                      array_filters, hint=hint,
                                      session=session, **kwargs)

    def save(self, to_save, manipulate=True, check_keys=True, **kwargs):
        """Save a document in this collection.

        **DEPRECATED** - Use :meth:`insert_one` or :meth:`replace_one` instead.

        .. versionchanged:: 3.0
           Removed the `safe` parameter. Pass ``w=0`` for unacknowledged write
           operations.
        """
        warnings.warn("save is deprecated. Use insert_one or replace_one "
                      "instead", DeprecationWarning, stacklevel=2)
        common.validate_is_document_type("to_save", to_save)

        write_concern = None
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        if kwargs:
            write_concern = WriteConcern(**kwargs)

        if not (isinstance(to_save, RawBSONDocument) or "_id" in to_save):
            return self._insert(
                to_save, True, check_keys, manipulate, write_concern)
        else:
            self._update_retryable(
                {"_id": to_save["_id"]}, to_save, True,
                check_keys, False, manipulate, write_concern,
                collation=collation)
            return to_save.get("_id")

    def insert(self, doc_or_docs, manipulate=True,
               check_keys=True, continue_on_error=False, **kwargs):
        """Insert a document(s) into this collection.

        **DEPRECATED** - Use :meth:`insert_one` or :meth:`insert_many` instead.

        .. versionchanged:: 3.0
           Removed the `safe` parameter. Pass ``w=0`` for unacknowledged write
           operations.
        """
        warnings.warn("insert is deprecated. Use insert_one or insert_many "
                      "instead.", DeprecationWarning, stacklevel=2)
        write_concern = None
        if kwargs:
            write_concern = WriteConcern(**kwargs)
        return self._insert(doc_or_docs, not continue_on_error,
                            check_keys, manipulate, write_concern)

    def update(self, spec, document, upsert=False, manipulate=False,
               multi=False, check_keys=True, **kwargs):
        """Update a document(s) in this collection.

        **DEPRECATED** - Use :meth:`replace_one`, :meth:`update_one`, or
        :meth:`update_many` instead.

        .. versionchanged:: 3.0
           Removed the `safe` parameter. Pass ``w=0`` for unacknowledged write
           operations.
        """
        warnings.warn("update is deprecated. Use replace_one, update_one or "
                      "update_many instead.", DeprecationWarning, stacklevel=2)
        common.validate_is_mapping("spec", spec)
        common.validate_is_mapping("document", document)
        if document:
            # If a top level key begins with '$' this is a modify operation
            # and we should skip key validation. It doesn't matter which key
            # we check here. Passing a document with a mix of top level keys
            # starting with and without a '$' is invalid and the server will
            # raise an appropriate exception.
            first = next(iter(document))
            if first.startswith('$'):
                check_keys = False

        write_concern = None
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        if kwargs:
            write_concern = WriteConcern(**kwargs)
        return self._update_retryable(
            spec, document, upsert, check_keys, multi, manipulate,
            write_concern, collation=collation)

    def remove(self, spec_or_id=None, multi=True, **kwargs):
        """Remove a document(s) from this collection.

        **DEPRECATED** - Use :meth:`delete_one` or :meth:`delete_many` instead.

        .. versionchanged:: 3.0
           Removed the `safe` parameter. Pass ``w=0`` for unacknowledged write
           operations.
        """
        warnings.warn("remove is deprecated. Use delete_one or delete_many "
                      "instead.", DeprecationWarning, stacklevel=2)
        if spec_or_id is None:
            spec_or_id = {}
        if not isinstance(spec_or_id, abc.Mapping):
            spec_or_id = {"_id": spec_or_id}
        write_concern = None
        collation = validate_collation_or_none(kwargs.pop('collation', None))
        if kwargs:
            write_concern = WriteConcern(**kwargs)
        return self._delete_retryable(
            spec_or_id, multi, write_concern, collation=collation)

    def find_and_modify(self, query={}, update=None,
                        upsert=False, sort=None, full_response=False,
                        manipulate=False, **kwargs):
        """Update and return an object.

        **DEPRECATED** - Use :meth:`find_one_and_delete`,
        :meth:`find_one_and_replace`, or :meth:`find_one_and_update` instead.
        """
        warnings.warn("find_and_modify is deprecated, use find_one_and_delete"
                      ", find_one_and_replace, or find_one_and_update instead",
                      DeprecationWarning, stacklevel=2)

        if not update and not kwargs.get('remove', None):
            raise ValueError("Must either update or remove")

        if update and kwargs.get('remove', None):
            raise ValueError("Can't do both update and remove")

        # No need to include empty args
        if query:
            kwargs['query'] = query
        if update:
            kwargs['update'] = update
        if upsert:
            kwargs['upsert'] = upsert
        if sort:
            # Accept a list of tuples to match Cursor's sort parameter.
            if isinstance(sort, list):
                kwargs['sort'] = helpers._index_document(sort)
            # Accept OrderedDict, SON, and dict with len == 1 so we
            # don't break existing code already using find_and_modify.
            elif (isinstance(sort, ORDERED_TYPES) or
                  isinstance(sort, dict) and len(sort) == 1):
                warnings.warn("Passing mapping types for `sort` is deprecated,"
                              " use a list of (key, direction) pairs instead",
                              DeprecationWarning, stacklevel=2)
                kwargs['sort'] = sort
            else:
                raise TypeError("sort must be a list of (key, direction) "
                                "pairs, a dict of len 1, or an instance of "
                                "SON or OrderedDict")

        fields = kwargs.pop("fields", None)
        if fields is not None:
            kwargs["fields"] = helpers._fields_list_to_dict(fields, "fields")

        collation = validate_collation_or_none(kwargs.pop('collation', None))

        cmd = SON([("findAndModify", self.__name)])
        cmd.update(kwargs)

        write_concern = self._write_concern_for_cmd(cmd, None)

        def _find_and_modify(session, sock_info, retryable_write):
            if (sock_info.max_wire_version >= 4 and
                    not write_concern.is_server_default):
                cmd['writeConcern'] = write_concern.document
            result = self._command(
                sock_info, cmd, read_preference=ReadPreference.PRIMARY,
                collation=collation,
                session=session, retryable_write=retryable_write,
                user_fields=_FIND_AND_MODIFY_DOC_FIELDS)

            _check_write_command_response(result)
            return result

        out = self.__database.client._retryable_write(
            write_concern.acknowledged, _find_and_modify, None)

        if full_response:
            return out
        else:
            document = out.get('value')
            if manipulate:
                document = self.__database._fix_outgoing(document, self)
            return document

    def __iter__(self):
        return self

    def __next__(self):
=======
        common.validate_list_or_none("array_filters", array_filters)
        kwargs["update"] = update
        if comment is not None:
            kwargs["comment"] = comment
        return self.__find_and_modify(
            filter,
            projection,
            sort,
            upsert,
            return_document,
            array_filters,
            hint=hint,
            let=let,
            session=session,
            **kwargs,
        )

    # See PYTHON-3084.
    __iter__ = None

    def __next__(self) -> NoReturn:
>>>>>>> origin/master
        raise TypeError("'Collection' object is not iterable")

    next = __next__

<<<<<<< HEAD
    def __call__(self, *args, **kwargs):
        """This is only here so that some API misusages are easier to debug.
        """
        if "." not in self.__name:
            raise TypeError("'Collection' object is not callable. If you "
                            "meant to call the '%s' method on a 'Database' "
                            "object it is failing because no such method "
                            "exists." %
                            self.__name)
        raise TypeError("'Collection' object is not callable. If you meant to "
                        "call the '%s' method on a 'Collection' object it is "
                        "failing because no such method exists." %
                        self.__name.split(".")[-1])
=======
    def __call__(self, *args: Any, **kwargs: Any) -> NoReturn:
        """This is only here so that some API misusages are easier to debug."""
        if "." not in self.__name:
            raise TypeError(
                "'Collection' object is not callable. If you "
                "meant to call the '%s' method on a 'Database' "
                "object it is failing because no such method "
                "exists." % self.__name
            )
        raise TypeError(
            "'Collection' object is not callable. If you meant to "
            "call the '%s' method on a 'Collection' object it is "
            "failing because no such method exists." % self.__name.split(".")[-1]
        )
>>>>>>> origin/master
