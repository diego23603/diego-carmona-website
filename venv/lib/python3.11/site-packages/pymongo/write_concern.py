# Copyright 2014-present MongoDB, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools for working with write concerns."""
<<<<<<< HEAD

from bson.py3compat import integer_types, string_type
from pymongo.errors import ConfigurationError


class WriteConcern(object):
    """WriteConcern

    :Parameters:
        - `w`: (integer or string) Used with replication, write operations
=======
from __future__ import annotations

from typing import Any, Optional, Union

from pymongo.errors import ConfigurationError


# Duplicated here to avoid a circular import.
def validate_boolean(option: str, value: Any) -> bool:
    """Validates that 'value' is True or False."""
    if isinstance(value, bool):
        return value
    raise TypeError(f"{option} must be True or False, was: {option}={value}")


class WriteConcern:
    """WriteConcern

    :param w: (integer or string) Used with replication, write operations
>>>>>>> origin/master
          will block until they have been replicated to the specified number
          or tagged set of servers. `w=<integer>` always includes the replica
          set primary (e.g. w=3 means write to the primary and wait until
          replicated to **two** secondaries). **w=0 disables acknowledgement
          of write operations and can not be used with other write concern
          options.**
<<<<<<< HEAD
        - `wtimeout`: (integer) Used in conjunction with `w`. Specify a value
          in milliseconds to control how long to wait for write propagation
          to complete. If replication does not complete in the given
          timeframe, a timeout exception is raised.
        - `j`: If ``True`` block until write operations have been committed
          to the journal. Cannot be used in combination with `fsync`. Prior
          to MongoDB 2.6 this option was ignored if the server was running
          without journaling. Starting with MongoDB 2.6 write operations will
          fail with an exception if this option is used when the server is
          running without journaling.
        - `fsync`: If ``True`` and the server is running without journaling,
=======
    :param wtimeout: (integer) **DEPRECATED** Used in conjunction with `w`.
          Specify a value in milliseconds to control how long to wait for write
          propagation to complete. If replication does not complete in the given
          timeframe, a timeout exception is raised.
    :param j: If ``True`` block until write operations have been committed
          to the journal. Cannot be used in combination with `fsync`. Write
          operations will fail with an exception if this option is used when
          the server is running without journaling.
    :param fsync: If ``True`` and the server is running without journaling,
>>>>>>> origin/master
          blocks until the server has synced all data files to disk. If the
          server is running with journaling, this acts the same as the `j`
          option, blocking until write operations have been committed to the
          journal. Cannot be used in combination with `j`.
<<<<<<< HEAD
=======


    .. versionchanged:: 4.7
        Deprecated parameter ``wtimeout``, use :meth:`~pymongo.timeout`.
>>>>>>> origin/master
    """

    __slots__ = ("__document", "__acknowledged", "__server_default")

<<<<<<< HEAD
    def __init__(self, w=None, wtimeout=None, j=None, fsync=None):
        self.__document = {}
        self.__acknowledged = True

        if wtimeout is not None:
            if not isinstance(wtimeout, integer_types):
=======
    def __init__(
        self,
        w: Optional[Union[int, str]] = None,
        wtimeout: Optional[int] = None,
        j: Optional[bool] = None,
        fsync: Optional[bool] = None,
    ) -> None:
        self.__document: dict[str, Any] = {}
        self.__acknowledged = True

        if wtimeout is not None:
            if not isinstance(wtimeout, int):
>>>>>>> origin/master
                raise TypeError("wtimeout must be an integer")
            if wtimeout < 0:
                raise ValueError("wtimeout cannot be less than 0")
            self.__document["wtimeout"] = wtimeout

        if j is not None:
<<<<<<< HEAD
            if not isinstance(j, bool):
                raise TypeError("j must be True or False")
            self.__document["j"] = j

        if fsync is not None:
            if not isinstance(fsync, bool):
                raise TypeError("fsync must be True or False")
            if j and fsync:
                raise ConfigurationError("Can't set both j "
                                         "and fsync at the same time")
=======
            validate_boolean("j", j)
            self.__document["j"] = j

        if fsync is not None:
            validate_boolean("fsync", fsync)
            if j and fsync:
                raise ConfigurationError("Can't set both j and fsync at the same time")
>>>>>>> origin/master
            self.__document["fsync"] = fsync

        if w == 0 and j is True:
            raise ConfigurationError("Cannot set w to 0 and j to True")

        if w is not None:
<<<<<<< HEAD
            if isinstance(w, integer_types):
                if w < 0:
                    raise ValueError("w cannot be less than 0")
                self.__acknowledged = w > 0
            elif not isinstance(w, string_type):
=======
            if isinstance(w, int):
                if w < 0:
                    raise ValueError("w cannot be less than 0")
                self.__acknowledged = w > 0
            elif not isinstance(w, str):
>>>>>>> origin/master
                raise TypeError("w must be an integer or string")
            self.__document["w"] = w

        self.__server_default = not self.__document

    @property
<<<<<<< HEAD
    def is_server_default(self):
=======
    def is_server_default(self) -> bool:
>>>>>>> origin/master
        """Does this WriteConcern match the server default."""
        return self.__server_default

    @property
<<<<<<< HEAD
    def document(self):
=======
    def document(self) -> dict[str, Any]:
>>>>>>> origin/master
        """The document representation of this write concern.

        .. note::
          :class:`WriteConcern` is immutable. Mutating the value of
          :attr:`document` does not mutate this :class:`WriteConcern`.
        """
        return self.__document.copy()

    @property
<<<<<<< HEAD
    def acknowledged(self):
=======
    def acknowledged(self) -> bool:
>>>>>>> origin/master
        """If ``True`` write operations will wait for acknowledgement before
        returning.
        """
        return self.__acknowledged

<<<<<<< HEAD
    def __repr__(self):
        return ("WriteConcern(%s)" % (
            ", ".join("%s=%s" % kvt for kvt in self.__document.items()),))

    def __eq__(self, other):
=======
    def __repr__(self) -> str:
        return "WriteConcern({})".format(
            ", ".join("{}={}".format(*kvt) for kvt in self.__document.items())
        )

    def __eq__(self, other: Any) -> bool:
>>>>>>> origin/master
        if isinstance(other, WriteConcern):
            return self.__document == other.document
        return NotImplemented

<<<<<<< HEAD
    def __ne__(self, other):
=======
    def __ne__(self, other: Any) -> bool:
>>>>>>> origin/master
        if isinstance(other, WriteConcern):
            return self.__document != other.document
        return NotImplemented


DEFAULT_WRITE_CONCERN = WriteConcern()
